
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Sandbox Delta 0.7.1c</title>
  <!-- Webapp metadata -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Sandbox Delta">
  <meta name="application-name" content="Sandbox Delta">
  <link rel="icon" type="image/x-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAJhSURBVFhH7ZY9aBRBGIbfvdwld7lL7hJz+YnJJcYYY0gMwUQsRFELCwutRBELGwutxFZtRBDBwkIQRBBE0MbGRrAQRLAQRBAsgoUWFhYWFhYWYp7vnNm9XdnLzwXkwBcedmdnZ9/vne+b2bvCcRxsZRXWvzet/G6HyWRSxONxEYvFRDQaFeFwWIRCIeHz+YTP6xVer1d4PB7hdruF2+USLpdLOJ1O4XA4hN1uFzabTVitVmGxWITZbBYmk0mYTCZhNBqFwWAQer1e6HQ6odVqhUajEWq1WqhUKqFUKoVCoRByuVzI5XIhk8mETCYTUqlUSCQSIRaLBUVRQBAEQZIkQZRlQRRFQRAEQa/XC1qtVmi1WqHRaIRarRYqlUoolUqhUCiEXC4XMplMSKVSIZFIhFgsFlKpVMhkMiGXy4VCodh8AHVdF4VCIWQymZBKpUIikQixWCykUqmQyWRCLpcLhUIh5HK5kMlkQiqVColEIsRisZBKpUIqlQqZTCbkcrlQKBRCLpcLmUwmpFKpkEgkQiwWC6lUKmQymZDL5UIhXwXweDwbD8AZcLvdwuVyCYfDIex2u7DZbMJqtQqLxSLMZrMwmUzCaDQKg8Eg9Hq90Ol0QqvVCo1GI9RqtVCpVEKpVAqFQiHkcrmQyWRCKpUKiUQixGKxoChKEIIgCJIkCaIsCqIoCgaDQWi1WqHRaIRarRYqlUoolUqhUCiEXC4XMplMSKVSIZFIhFgsFhRFEQRBECRJEkRZFERRFPR6vdBqtUKj0Qi1Wi1UKpVQKpVCoVAIuVwuZDKZkEqlQiKRCLFYLCiKIgiCIEiSJIiyKIiiKPwXAYQQfwBCxA1TnWK6GAAAAABJRU5ErkJggg==">
  <link rel="apple-touch-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAJhSURBVFhH7ZY9aBRBGIbfvdwld7lL7hJz+YnJJcYYY0gMwUQsRFELCwutRBELGwutxFZtRBDBwkIQRBBE0MbGRrAQRLAQRBAsgoUWFhYWFhYWYp7vnNm9XdnLzwXkwBcedmdnZ9/vne+b2bvCcRxsZRXWvzet/G6HyWRSxONxEYvFRDQaFeFwWIRCIeHz+YTP6xVer1d4PB7hdruF2+USLpdLOJ1O4XA4hN1uFzabTVitVmGxWITZbBYmk0mYTCZhNBqFwWAQer1e6HQ6odVqhUajEWq1WqhUKqFUKoVCoRByuVzI5XIhk8mETCYTUqlUSCQSIRaLBUVRQBAEQZIkQZRlQRRFQRAEQa/XC1qtVmi1WqHRaIRarRYqlUoolUqhUCiEXC4XMplMSKVSIZFIhFgsFlKpVMhkMiGXy4VCodh8AHVdF4VCIWQymZBKpUIikQixWCykUqmQyWRCLpcLhUIh5HK5kMlkQiqVColEIsRisZBKpUIqlQqZTCbkcrlQKBRCLpcLmUwmpFKpkEgkQiwWC6lUKmQymZDL5UIhXwXweDwbD8AZcLvdwuVyCYfDIex2u7DZbMJqtQqLxSLMZrMwmUzCaDQKg8Eg9Hq90Ol0QqvVCo1GI9RqtVCpVEKpVAqFQiHkcrmQyWRCKpUKiUQixGKxoChKEIIgCJIkCaIsCqIoCgaDQWi1WqHRaIRarRYqlUoolUqhUCiEXC4XMplMSKVSIZFIhFgsFhRFEQRBECRJEkRZFERRFPR6vdBqtUKj0Qi1Wi1UKpVQKpVCoVAIuVwuZDKZkEqlQiKRCLFYLCiKIgiCIEiSJIiyKIiiKPwXAYQQfwBCxA1TnWK6GAAAAABJRU5ErkJggg==">

  <style>
    /* Basic layout: center the page content, side panel on the right */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    #game-container {
      overflow: auto;
    }

    .playing #game-container {
      overflow: hidden;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #222;
      color: #fff;
      font-family: Arial, sans-serif;
      box-sizing: border-box;
    }
    /* The main container: grid + side panel horizontally */
    #mainContainer {
      display: flex;
      flex-direction: row;
      justify-content: center;
      margin: 0 auto;
      padding: 10px;
      box-sizing: border-box;
      width: 100%;
      height: 100vh;
      gap: 20px;
    }
    /* The game grid; its size will be determined by GRID_SIZE */
    #grid {
      flex: 1;
      max-width: calc(100vh - 20px);
      aspect-ratio: 1;
      background-color: #555;
      user-select: none;
      cursor: crosshair;
      display: grid;
      grid-template-columns: repeat(50, 1fr);
      grid-template-rows: repeat(50, 1fr);
      position: relative;
    }
    .cell {
      width: 100%;
      height: 100%;
      background-color: #000;
      box-sizing: border-box;
    }
    /* Hover overlay for stroke highlighting */
    #hoverOverlay {
      position: absolute;
      pointer-events: none;
      border: 2px dashed yellow;
      background-color: rgba(255, 255, 0, 0.2);
      display: none;
      box-sizing: border-box;
    }
    /* Side panel: now wider */
    #sidePanel {
      display: flex;
      flex-direction: column;
      width: 400px;
      min-width: 400px;
      height: calc(100vh - 20px);
      border: 2px solid #444;
      box-sizing: border-box;
    }
    /* Container for the two scrollable areas side-by-side */
    #sideContent {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    /* Element list scroll area */
    #elementScroll {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      box-sizing: border-box;
    }
    /* Custom scrollbar for element list */
    #elementScroll::-webkit-scrollbar {
      width: 8px;
    }
    #elementScroll::-webkit-scrollbar-track {
      background: #444;
      border-radius: 4px;
    }
    #elementScroll::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 4px;
    }
    #elementScroll::-webkit-scrollbar-thumb:hover {
      background: #aaa;
    }
    /* Search box for elements */
    #toolSearchContainer {
      margin-bottom: 10px;
      width: 100%;
    }
    #toolSearch {
      width: 100%;
      background-color: #333;
      color: #fff;
      border: 1px solid #888;
      border-radius: 3px;
      padding: 5px;
      box-sizing: border-box;
      font-size: 14px;
    }
    #toolSearch::placeholder {
      color: #bbb;
    }
    /* Toolbar (element icons) */
    #toolbar {
      display: flex;
      flex-wrap: wrap;
    }
    .tool {
      position: relative;
      width: 60px;
      height: 40px;
      margin: 5px;
      border: 2px solid #fff;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      background-color: #333;
    }
    .tool span {
      position: absolute;
      font-size: 10px;
      font-weight: bold;
      color: #000;
      bottom: 2px;
      right: 2px;
      pointer-events: none;
    }
    .tool.selected {
      border: 2px solid #ffd700;
    }
    /* Category menu (tabs) placed to the right in its own scroll area */
    #categoryMenu {
      width: 150px;
      overflow-y: auto;
      padding: 10px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
    }
    #categoryMenu button {
      width: 100%;
      margin-bottom: 5px;
      padding: 10px;
      text-align: center;
      background-color: #333;
      color: #fff;
      border: 1px solid #888;
      border-radius: 3px;
      cursor: pointer;
    }
    #categoryMenu button.selectedCat {
      border: 2px solid #ffd700;
    }
    /* Custom scrollbar for category menu */
    #categoryMenu::-webkit-scrollbar {
      width: 8px;
    }
    #categoryMenu::-webkit-scrollbar-track {
      background: #444;
      border-radius: 4px;
    }
    #categoryMenu::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 4px;
    }
    #categoryMenu::-webkit-scrollbar-thumb:hover {
      background: #aaa;
    }
    /* Element color classes */
    .sand         { background-color: #f4a460; }
    .wall         { background-color: #666666; }
    .water        { background-color: #1e90ff; }
    .lava         { background-color: #ff4500; }
    .stone        { background-color: #808080; }
    .water-vapor  { background-color: #e0e0e0; }
    .cloud        { background-color: #ffffff; }
    .eraser       { background-color: pink; border: 2px solid #fff; }
    .copper       { background-color: #b87333; }
    .steel        { background-color: #aaaaaa; }
    .ice          { background-color: #cceeff; }
    .wood         { background-color: #3B220E; }
    .fire         { background-color: #ffcc00; }
    .smoke        { background-color: #666666; }
    .burning-wood { background-color: #5a3310; }
    .ash          { background-color: #444444; }
    .glass        { background-color: #c2e9fb; }
    .bomb         { background-color: #006400; border: 2px solid #000; }
    .dirt         { background-color: #7B5E42; }
    .wet-dirt     { background-color: #4d2e12; }
    .wheat-seeds  { background-color: #bca136; }
    .wheat        { background-color: #c2b280; }
    .flour        { background-color: #f5f5dc; }
    .dough        { background-color: #d2b48c; }
    .bread        { background-color: #f4c986; }
    .burning-organic { background-color: #6a3400; }
    .root         { background-color: #4a3a2f; }
    .spark        { background-color: #ffdd00; border: 1px solid #ffbb00; }
    .charged-copper { background-color: #ff8c00; }
    .charged-down-copper { background-color: #cc6600; }
    .oak-seeds       { background-color: #32CD32; }
    .oak-leaves      { background-color: #228B22; }
    .oak-baby-leaves { background-color: #66bb6a; }
    .dead-oak        { background-color: #777777; }
    .wet-sand        { background-color: #d2a679; }
    .grass           { background-color: #00aa00; }
    .dead-plant      { background-color: #555555; }
    .burning-leaves  { background-color: #a0522d; }
    .burning-root    { background-color: #ff4500; }
    .dead-root       { background-color: #555555; }
    .gas             { background-color: rgba(200,200,200,0.2); }
    .burning-gas     { background-color: #ff6666; opacity: 0.75; }
    .acid            { background-color: #90EE90; }
    .acid-steam      { background-color: #98FB98; opacity: 0.7; }
    .acid-cloud      { background-color: #98FB98; }
    .slime           { background-color: #006400; }
    /* New element classes */
    .carbon-dioxide  { background-color: rgba(128,128,128,0.2); }
    .oxygen          { background-color: rgba(200,230,255,0.2); }
    .bird            { background-color: #B8860B; }
    .meat            { background-color: #FF6B6B; }
    .cooked-meat     { background-color: #8B4513; }
    .cobblestone     { background-color: #808080; }
    .oil             { background-color: #2F4F4F; }
    /* cooler & heater */
    .cooler { background-color: #3399ff; }
    .heater { background-color: #ff3333; }
    /* Heat Separator, Input, Output, Not Gate, And Gate, Blocker */
    .heat-separator          { background-color: #ffef96; }
    .charged-heat-separator  { background-color: #ffe033; }
    .charged-down-heat-separator { background-color: #ffd700; }
    .input            { background-color: #646464; }
    .charged-input    { background-color: #ffff77; }
    .output           { background-color: #3636ff; }
    .charged-output   { background-color: #8888ff; }
    .not-gate         { background-color: #a15050; }
    .and-gate         { background-color: #405050; }
    .blocker          { background-color: #856fa8; }
    .charged-blocker  { background-color: #9b50a3; }
    /* Cloner */
    .cloner { background-color: #cc00cc; }
    /* New elements: Coal & Coal Lump */
    .coal         { background-color: #202020; }
    .coal-lump    { background-color: #303030; }
    /* New element: Thermite – tool styling */
    .thermite     { background-color: #AA4444; }
    .bomb         { background-color: #ff0000; }
    .big-bomb     { background-color: #ff3333; }
    .water-bomb   { background-color: #3366ff; }
    .fire-bomb    { background-color: #ff6600; }
    .cryo-bomb    { background-color: #00ccff; }
    .nuke-bomb    { background-color: #33cc33; }  

    /* HUD area for temp, element info, and FPS */
    #hud {
      background: rgba(0,0,0,0.7);
      padding: 5px;
      border: 1px solid #444;
      font-size: 14px;
      line-height: 1.3;
      box-sizing: border-box;
    }
    #hud div { margin: 5px 0; }
    /* Bottom controls */
    #bottomControls {
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 5px;
      box-sizing: border-box;
    }
    #speedContainer {
      margin-bottom: 10px;
      text-align: center;
      color: #fff;
    }
    #speed {
      -webkit-appearance: none;
      width: 120px;
      background: #444;
      outline: none;
      border-radius: 5px;
      border: 1px solid #888;
      height: 6px;
      cursor: pointer;
    }
    #speed::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 12px;
      width: 12px;
      background: #888;
      border-radius: 50%;
      cursor: pointer;
      border: 1px solid #aaa;
    }
    #speedValue {
      margin-left: 5px;
      min-width: 40px;
      text-align: right;
      display: inline-block;
    }
    #clearAllBtn {
      background-color: #444;
      border: 1px solid #888;
      border-radius: 3px;
      color: #fff;
      font-size: 14px;
      padding: 8px 12px;
      cursor: pointer;
    }
    #clearAllBtn:hover { background-color: #555; }
    /* Extra Sidebar Buttons */
    #optionsButtonContainer, #saveLoadButtonContainer, #modButtonContainer {
      text-align: center;
    }
    #optionsButton, #saveLoadButton, #modButton {
      background-color: #444;
      border: 1px solid #888;
      border-radius: 3px;
      color: #fff;
      padding: 8px 12px;
      cursor: pointer;
      margin: 5px;
    }
    #optionsButton:hover, #saveLoadButton:hover, #modButton:hover {
      background-color: #555;
    }
    /* Mod Manager Modal styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: rgba(0,0,0,0.8);
    }
    .modal .modal-content {
      background-color: #333;
      margin: 5% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
      max-width: 600px;
      max-height: 90vh;
      position: relative;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }
    .modal .close {
      color: #aaa;
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      z-index: 10;
    }
    .modal .close:hover,
    .modal .close:focus {
      color: #fff;
      text-decoration: none;
      cursor: pointer;
    }
    .modal input[type="text"],
    .modal textarea,
    .modal select {
      width: 100%;
      padding: 8px;
      margin: 5px 0;
      background-color: #222;
      color: #fff;
      border: 1px solid #888;
      border-radius: 3px;
      box-sizing: border-box;
    }
    .modal button {
      background-color: #444;
      border: 1px solid #888;
      border-radius: 3px;
      color: #fff;
      padding: 8px 12px;
      cursor: pointer;
    }
    .modal button:hover {
      background-color: #555;
    }
    /* Styles for mod cards in the mod menu */
    .modCard {
      background-color: #444;
      padding: 10px;
      margin: 10px 0;
      border-radius: 5px;
    }
    .modCard h3 {
      margin: 0;
      font-size: 18px;
    }
    .modCard p {
      font-size: 14px;
      margin: 5px 0;
    }
    .modCard small {
      font-size: 12px;
      color: #aaa;
    }
    .modCard small.incompatible {
      color: red;
    }
    .modCard button {
      background-color: #555;
      border: 1px solid #888;
      border-radius: 3px;
      color: #fff;
      padding: 5px 10px;
      margin-right: 5px;
      cursor: pointer;
    }
    .modCard button:hover {
      background-color: #666;
    }
    .acid          { background-color: #90EE90; }
    .acid-steam    { background-color: #98FB98; opacity: 0.7; }
    .acid-cloud    { background-color: #98FB98; }
    .slime         { background-color: #006400; }
    /* Tool styles */
    .tool.heat { background: linear-gradient(45deg, #ff4500, #ffd700); }
    .tool.cool { background: linear-gradient(45deg, #00bfff, #87ceeb); }
    .tool.cook { background-color: #deb887; }
    .tool.mix { background: repeating-linear-gradient(45deg, #444, #666 10px); }
    .tool.move { background-color: #4169e1; }
    .tool.sponge { background-color: #ffa07a; }
    .tool.extinguish { background-color: #4682b4; }
    /* Add to existing styles */
    .options-section {
      margin: 15px 0;
      padding: 10px;
      border: 1px solid #444;
      border-radius: 6px;
      transition: background-color 0.2s ease;
    }

    .options-section.experimental {
      background-color: #333;
      border-color: #ffd700;
    }

    .options-section h3 {
      margin-top: 0;
      color: #ffd700;
      font-size: 1.2em;
      letter-spacing: 0.5px;
    }

    .options-button {
      background-color: #444;
      border: 1px solid #888;
      border-radius: 3px;
      color: #fff;
      padding: 8px 12px;
      cursor: pointer;
      width: 100%;
      margin: 5px 0;
    }

    .options-button:hover {
      background-color: #555;
    }

    #popOutWindow {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #222;
      padding: 10px;
      border: 2px solid #444;
      border-radius: 5px;
      display: none;
      z-index: 2000;
    }

    /* Mobile touch support */
    @media (max-width: 1024px) {
      #mainContainer {
        flex-direction: column;
        height: auto;
      }
      #grid {
        width: 100%;
        max-width: none;
        height: auto;
      }
      #sidePanel {
        width: 100%;
        min-width: 0;
        height: auto;
      }
    }

    /* Add dynamic lighting styles */
    .cell.lit {
      transition: background-color 0.1s ease;
    }

    .cell.glass.lit {
      transition: background-color 0.2s ease;
      mix-blend-mode: screen;
    }

    /* Add to existing styles */
    .option-item {
      margin: 15px 0;
      padding: 10px;
      border: 1px solid #444;
      border-radius: 6px;
      transition: border-color 0.2s ease;
    }

    .option-item:hover {
      border-color: #666;
    }

    .option-description {
      color: #888;
      font-size: 0.9em;
      margin: 5px 0 0 0;
      font-style: italic;
    }

    /* Main menu specific styling */
    .main-menu {
      text-align: center;
      background-color: rgba(34, 34, 34, 0.95) !important;
      min-height: 500px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 40px 20px;
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }

    .main-menu h1 {
      font-size: 3.5em;
      color: #fff;
      margin: 0;
      padding: 20px 0;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      background: linear-gradient(45deg, #4a4a4a, #2a2a2a);
      border-radius: 10px;
      margin-bottom: 40px;
    }

    .main-menu-buttons {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 30px;
      align-items: center;
      margin: 20px 0;
    }

    .main-menu-button {
      background: linear-gradient(45deg, #444, #333);
      border: 2px solid #666;
      border-radius: 10px;
      color: #fff;
      padding: 20px 40px;
      font-size: 1.4em;
      cursor: pointer;
      width: 250px;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 2px;
      position: relative;
      overflow: hidden;
    }

    .main-menu-button:hover {
      background: linear-gradient(45deg, #555, #444);
      border-color: #888;
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
    }

    .main-menu-button:active {
      transform: scale(0.98);
    }

    .engine-info {
      padding: 20px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      margin-top: 20px;
    }

    /* Help Menu Styling */
    .help-menu {
      display: none;
      position: fixed;
      z-index: 1100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
    }

    .help-content {
      background-color: #333;
      margin: 5% auto;
      padding: 30px;
      width: 80%;
      max-width: 800px;
      max-height: 80vh;
      border-radius: 15px;
      position: relative;
      display: flex;
      flex-direction: column;
      color: #fff;
    }

    .help-page {
      display: none;
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    .help-page.active {
      display: block;
    }

    .help-navigation {
      display: flex;
      justify-content: space-between;
      padding: 20px 0;
      border-top: 1px solid #444;
      margin-top: 20px;
    }

    .help-nav-button {
      background: #444;
      border: none;
      padding: 10px 20px;
      color: #fff;
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.3s;
    }

    .help-nav-button:hover {
      background: #555;
    }

    .help-nav-button:disabled {
      background: #333;
      color: #666;
      cursor: not-allowed;
    }

    .help-close {
      position: absolute;
      right: 20px;
      top: 20px;
      font-size: 24px;
      color: #fff;
      cursor: pointer;
      background: none;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
    }

    .help-close:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    /* Options modal height fix */
    .modal-content {
      margin: 2vh auto;
      max-height: 96vh;
    }
    
    /* Options content scrollable styles */
    .options-content {
      overflow-y: auto;
      padding-right: 10px;
      margin-right: -10px;
      flex: 1;
      max-height: calc(80vh - 120px);
      scrollbar-width: thin;
      scrollbar-color: #666 #333;
    }
    
    .options-content::-webkit-scrollbar {
      width: 8px;
    }
    
    .options-content::-webkit-scrollbar-track {
      background: #333;
      border-radius: 4px;
    }
    
    .options-content::-webkit-scrollbar-thumb {
      background-color: #666;
      border-radius: 4px;
    }
    
    .options-content::-webkit-scrollbar-thumb:hover {
      background-color: #888;
    }
    
    #optionsModal h2 {
      position: sticky;
      top: 0;
      background-color: #333;
      margin-top: 0;
      padding-top: 10px;
      z-index: 5;
      color: #ffd700;
      text-align: center;
      font-size: 1.6em;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    #optionsModal #applyOptionsButton {
      display: none !important;
      margin-top: 15px;
      background: linear-gradient(to bottom, #666, #444);
      border: none;
      border-radius: 4px;
      padding: 10px 20px;
      color: #fff;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      position: sticky;
      bottom: 0;
      width: calc(100% - 20px);
      margin-left: auto;
      margin-right: auto;
      border-top: 1px solid #444;
      padding-top: 15px;
      z-index: 5;
      background-color: #333;
    }
    
    #optionsModal #applyOptionsButton.show-clear-warning {
      display: block !important;
      background: linear-gradient(to bottom, #ff4444, #cc0000);
      color: white;
      font-weight: bold;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.02); }
      100% { transform: scale(1); }
    }
    
    /* Modal footer style */
    .modal-footer {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid #444;
      text-align: center;
    }

    /* Add to existing styles */
    .options-section.disabled {
      opacity: 0.5;
      pointer-events: none;
      position: relative;
    }

    .options-section.disabled::after {
      content: "Coming Soon";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 5px 10px;
      border-radius: 4px;
      color: #fff;
      font-size: 12px;
    }

    /* Confirmation Modal */
    .confirmation-modal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
    }

    .confirmation-content {
      background-color: #333;
      margin: 15% auto;
      padding: 20px;
      width: 300px;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      text-align: center;
      color: #fff;
    }

    .confirmation-buttons {
      margin-top: 20px;
      display: flex;
      justify-content: center;
      gap: 10px;
    }

    .confirmation-buttons button {
      padding: 8px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }

    .confirmation-yes {
      background-color: #4CAF50;
      color: white;
    }

    .confirmation-no {
      background-color: #f44336;
      color: white;
    }

    .confirmation-buttons button:hover {
      transform: scale(1.05);
    }

    /* Add styles for the apply button states */
    #applyOptionsButton {
      display: none;
    }

    #applyOptionsButton.show-clear-warning {
      display: block;
      background: linear-gradient(to bottom, #ff4444, #cc0000);
      color: white;
      font-weight: bold;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.02); }
      100% { transform: scale(1); }
    }
  </style>
</head>
<body>
  <!-- Main Menu Modal -->
  <div id="mainMenuModal" class="modal" style="display: block;">
    <div class="modal-content main-menu">
      <h1>Sandbox Delta</h1>
      <div class="main-menu-buttons">
        <button id="beginGameBtn" class="main-menu-button">Begin Game</button>
        <button id="helpBtn" class="main-menu-button">Help</button>
        <button id="modsMenuBtn" class="main-menu-button">Mods (Beta)</button>
      </div>
      <div class="engine-info">
        <span class="version-info">Sandbox Delta Version 0.7.1c</span>
        <span class="engine-version">Dabicco Engine 8.7.4</span>
      </div>
    </div>
  </div>

  <!-- Help Menu -->
  <div id="helpMenu" class="help-menu">
    <div class="help-content">
      <button class="help-close">&times;</button>
      <div class="help-page active" data-page="1">
        <h2>Welcome to Sandbox Delta</h2>
        <p>Sandbox Delta is a physics-based particle simulation game where you can experiment with various elements and their interactions. Create complex systems, generate reactions, and explore the possibilities!<br>The game is compiled on Dabicco Engine 8.7.4</p>
        
        <h3>Basic Controls</h3>
        <ul>
          <li>Left Click/Touch: Place selected element</li>
          <li>Right Click: Erase elements</li>
          <li>Mouse Wheel: Adjust brush size</li>
        </ul>

        <h3>Interface Overview</h3>
        <ul>
          <li>Main Grid: The simulation area where elements interact</li>
          <li>Side Panel: Contains element selection and categories</li>
          <li>Speed Slider: Controls simulation speed (0.0x to 4.0x)</li>
          <li>Element Search: Quick-find elements by name</li>
          <li>HUD: Shows temperature, selected element, and FPS</li>
        </ul>
      </div>

      <div class="help-page" data-page="2">
        <h2>Elements & Categories</h2>
        
        <h3>Basic Elements</h3>
        <ul>
          <li>Sand: Basic powder that falls and piles up</li>
          <li>Water: Flows and interacts with other elements</li>
          <li>Fire: Burns flammable materials and spreads</li>
          <li>Wood: Can be burned and supports plant growth</li>
          <li>Stone: Solid building material</li>
          <li>Wall: Indestructible barrier</li>
        </ul>

        <h3>Element Categories</h3>
        <ul>
          <li>Powders: Sand, Flour, Coal Lumps, etc.</li>
          <li>Liquids: Water, Lava, Oil, etc.</li>
          <li>Gases: Steam, Smoke, Gas, etc.</li>
          <li>Solids: Stone, Wood, Glass, etc.</li>
          <li>Life: Plants, Seeds, Birds, etc.</li>
          <li>Explosives: Bombs, Thermite</li>
          <li>Cooking: Dough, Bread, Meat</li>
          <li>Electricity: Copper, Circuits, Logic Gates</li>
        </ul>
      </div>

      <div class="help-page" data-page="3">
        <h2>Advanced Mechanics</h2>
        
        <h3>Temperature System</h3>
        <p>Elements have temperature properties that affect their behavior:</p>
        <ul>
          <li>Heat Transfer: Elements conduct heat between each other</li>
          <li>State Changes: Water boils to steam, lava cools to stone</li>
          <li>Reactions: High temperatures can cause burning, melting, or explosions</li>
          <li>Tools: Use Heat and Cool tools to manipulate temperature</li>
        </ul>

        <h3>Plant Growth</h3>
        <ul>
          <li>Wheat: Grows from seeds, produces flour</li>
          <li>Oak Trees: Complex growth with branches and leaves</li>
          <li>Grass: Spreads naturally on dirt</li>
          <li>Roots: Absorb water from wet soil</li>
        </ul>

        <h3>Special Tools</h3>
        <ul>
          <li>Mix Tool: Stirs elements together</li>
          <li>Move Tool: Precisely position elements</li>
          <li>Sponge: Removes burning materials</li>
          <li>Cook Tool: Process food items</li>
        </ul>
      </div>

      <div class="help-page" data-page="4">
        <h2>Advanced Features</h2>
        
        <h3>Electrical System</h3>
        <p>Create complex circuits and logic systems:</p>
        <ul>
          <li>Copper: Conducts electricity and heat</li>
          <li>Spark: Initiates electrical current</li>
          <li>Logic Gates: NOT, AND gates for circuits</li>
          <li>Input/Output: Control signal flow</li>
          <li>Heat Separator: Manages heat distribution</li>
        </ul>

        <h3>Chemical Reactions</h3>
        <ul>
          <li>Sand + Heat = Glass</li>
          <li>Water + Lava = Stone/Obsidian</li>
          <li>Flour + Water = Dough</li>
          <li>Dough + Heat = Bread</li>
          <li>Coal + Heat = Long-burning fuel</li>
        </ul>
      </div>

      <div class="help-page" data-page="5">
        <h2>Game Features</h2>
        
        <h3>Save System</h3>
        <ul>
          <li>Save/Load: Store and retrieve your creations</li>
          <li>Export: Share save files with other players</li>
          <li>Import: Load shared save files</li>
        </ul>

        <h3>World Generation</h3>
        <ul>
          <li>Terrain Generation: Create natural landscapes</li>
          <li>Cave Systems: Underground networks</li>
          <li>Ore Deposits: Find valuable materials</li>
          <li>Ecosystems: Plants and wildlife</li>
        </ul>

        <h3>Mod Support</h3>
        <ul>
          <li>Custom Elements: Add new materials</li>
          <li>New Behaviors: Modify element interactions</li>
          <li>Visual Effects: Change appearance</li>
          <li>Game Extensions: Add new features</li>
        </ul>

        <h3>Tips & Tricks</h3>
        <ul>
          <li>Use the search function to quickly find elements</li>
          <li>Adjust brush size for precise or broad placement</li>
          <li>Experiment with element combinations</li>
          <li>Watch temperature changes in the HUD</li>
          <li>Try the terrain generator for inspiration</li>
        </ul>
      </div>

      <div class="help-navigation">
        <button class="help-nav-button" id="prevPage" disabled>Previous Page</button>
        <span id="pageIndicator">Page 1 of 5</span>
        <button class="help-nav-button" id="nextPage">Next Page</button>
      </div>
    </div>
  </div>

  <script>
    // Help menu functionality
    document.addEventListener('DOMContentLoaded', function() {
      const helpMenu = document.getElementById('helpMenu');
      const helpBtn = document.getElementById('helpBtn');
      const closeHelpBtn = document.querySelector('.help-close');
      const prevPageBtn = document.getElementById('prevPage');
      const nextPageBtn = document.getElementById('nextPage');
      const pageIndicator = document.getElementById('pageIndicator');
      const pages = document.querySelectorAll('.help-page');
      let currentPage = 1;
      const totalPages = pages.length;

      function updatePageButtons() {
        prevPageBtn.disabled = currentPage === 1;
        nextPageBtn.disabled = currentPage === totalPages;
        pageIndicator.textContent = `Page ${currentPage} of ${totalPages}`;
      }

      function showPage(pageNum) {
        pages.forEach(page => page.classList.remove('active'));
        document.querySelector(`[data-page="${pageNum}"]`).classList.add('active');
        currentPage = pageNum;
        updatePageButtons();
      }

      helpBtn.addEventListener('click', () => {
        helpMenu.style.display = 'block';
        showPage(1);
      });

      closeHelpBtn.addEventListener('click', () => {
        helpMenu.style.display = 'none';
      });

      prevPageBtn.addEventListener('click', () => {
        if (currentPage > 1) showPage(currentPage - 1);
      });

      nextPageBtn.addEventListener('click', () => {
        if (currentPage < totalPages) showPage(currentPage + 1);
      });

      // Fix for load save functionality
      document.getElementById('createCanvasBtn').addEventListener('click', function() {
        const creationMode = document.getElementById('gameCreationMode').value;
        
        if (creationMode === 'load') {
          // Initialize with default settings
          initGrid(50);
          document.getElementById('newGameModal').style.display = 'none';
          document.getElementById('mainContainer').style.display = 'flex';
          
          // Show load menu
          const saveLoadModal = document.getElementById('saveLoadModal');
          saveLoadModal.style.display = 'block';
          saveLoadModal.querySelector('h2').textContent = 'Load';
          const saveSection = saveLoadModal.querySelector('div:first-of-type');
          if (saveSection) saveSection.style.display = 'none';
          updateSavedGamesList();
        } else {
          // Normal new game creation
          const size = parseInt(document.getElementById('newGameSizeSelect').value);
          const generateTerrain = document.getElementById('generateTerrainToggle').value === '1';
          
          initGrid(size);
          document.getElementById('newGameModal').style.display = 'none';
          document.getElementById('mainContainer').style.display = 'flex';
          
          if (generateTerrain) {
            generateTerrain();
          }
        }
      });
    });
  </script>

  <!-- New Game Modal -->
  <div id="newGameModal" class="modal">
    <div class="modal-content">
      <span id="closeNewGameModal" class="close">&times;</span>
      <h2>New Game</h2>
      <div class="options-section">
        <div class="option-item">
          <label for="gameCreationMode">Game Creation Mode:</label>
          <select id="gameCreationMode">
            <option value="new">New Game</option>
            <option value="load">Load Save</option>
          </select>
          <p class="option-description">Choose between creating a new game or loading an existing save.</p>
        </div>

        <div id="newGameOptions">
          <div class="option-item">
            <label for="newGameSizeSelect">Stage Size:</label>
            <select id="newGameSizeSelect">
              <option value="25">25x25x25</option>
              <option value="50" selected>50x50x50</option>
              <option value="75">75x75x75</option>
              <option value="100">100x100x100</option>
              <option value="125">125x125x125</option>
            </select>
            <p class="option-description">Changes the size of the simulation grid. Larger sizes may impact performance.</p>
          </div>

          <div class="option-item">
            <label for="generateTerrainToggle">Generate Terrain:</label>
            <select id="generateTerrainToggle">
              <option value="0">Off</option>
              <option value="1">On</option>
            </select>
            <p class="option-description">Start with a procedurally generated world containing caves, ores, and surface features.</p>
          </div>
        </div>
      </div>
      <button id="createCanvasBtn" class="main-menu-button">Create Canvas</button>
    </div>
  </div>

  <script>
    // Game version updated to 0.7.1c
    window.currentGameVersion = "0.7.1c";

    // Initialize main menu system
    document.addEventListener('DOMContentLoaded', function() {
      const mainContainer = document.getElementById('mainContainer');
      const mainMenuModal = document.getElementById('mainMenuModal');
      const newGameModal = document.getElementById('newGameModal');
      const saveLoadModal = document.getElementById('saveLoadModal');
      const modMenu = document.getElementById('modMenu');

      // Update version displays
      document.querySelector('.version-info').textContent = `Sandbox Delta Version ${window.currentGameVersion}`;

      // Hide main container initially
      mainContainer.style.display = 'none';

      // Begin Game button
      document.getElementById('beginGameBtn').addEventListener('click', function() {
        mainMenuModal.style.display = 'none';
        newGameModal.style.display = 'block';
      });

      // Mods button
      document.getElementById('modsMenuBtn').addEventListener('click', function() {
        mainMenuModal.style.display = 'none';
        modMenu.style.display = 'block';
        updateModListUI();
      });

      // Add game creation mode handling
      document.getElementById('gameCreationMode').addEventListener('change', function(e) {
        const newGameOptions = document.getElementById('newGameOptions');
        const createCanvasBtn = document.getElementById('createCanvasBtn');
        
        if (e.target.value === 'load') {
          newGameOptions.style.display = 'none';
          createCanvasBtn.textContent = 'Continue to Load';
        } else {
          newGameOptions.style.display = 'block';
          createCanvasBtn.textContent = 'Create Canvas';
        }
      });

    // Update Create Canvas button behavior
    document.getElementById('createCanvasBtn').addEventListener('click', function() {
      const creationMode = document.getElementById('gameCreationMode').value;
      
      if (creationMode === 'load') {
        // Initialize with default settings
        initGrid(50);
        newGameModal.style.display = 'none';
        mainContainer.style.display = 'flex';
        
        // Show load menu
        const saveLoadModal = document.getElementById('saveLoadModal');
        saveLoadModal.style.display = 'block';
        saveLoadModal.querySelector('h2').textContent = 'Load';
        const saveSection = saveLoadModal.querySelector('div:first-of-type');
        if (saveSection) saveSection.style.display = 'none';
        updateSavedGamesList();
      } else {
        // Normal new game creation
        const size = parseInt(document.getElementById('newGameSizeSelect').value);
        const shouldGenerateTerrain = document.getElementById('generateTerrainToggle').value === '1';
        
        initGrid(size);
        newGameModal.style.display = 'none';
        mainContainer.style.display = 'flex';
        
        if (shouldGenerateTerrain) {
          window.generateTerrain(); // Call the global function explicitly
        }
      }
    });

      // Close buttons for modals
      document.getElementById('closeNewGameModal').addEventListener('click', function() {
        newGameModal.style.display = 'none';
        mainMenuModal.style.display = 'block';
      });

      // When closing save/load or mods menu, return to main menu if game hasn't started
      const closeModMenu = document.getElementById('closeModMenu');
      const closeSaveLoadModal = document.getElementById('closeSaveLoadModal');

      closeModMenu.addEventListener('click', function() {
        modMenu.style.display = 'none';
        if (mainContainer.style.display === 'none') {
          mainMenuModal.style.display = 'block';
        }
      });

      closeSaveLoadModal.addEventListener('click', function() {
        saveLoadModal.style.display = 'none';
        if (mainContainer.style.display === 'none') {
          mainMenuModal.style.display = 'block';
        }
      });

      // Window click handlers
      window.addEventListener('click', function(event) {
        if (event.target === newGameModal) {
          newGameModal.style.display = 'none';
          mainMenuModal.style.display = 'block';
        }
        if (event.target === saveLoadModal) {
          saveLoadModal.style.display = 'none';
          if (mainContainer.style.display === 'none') {
            mainMenuModal.style.display = 'block';
          }
        }
        if (event.target === modMenu) {
          modMenu.style.display = 'none';
          if (mainContainer.style.display === 'none') {
            mainMenuModal.style.display = 'block';
          }
        }
      });
    });
  </script>

  <div id="mainContainer">
    <!-- The simulation grid (will be rebuilt based on stage size) -->
    <div id="grid">
      <!-- Hover overlay element -->
      <div id="hoverOverlay"></div>
    </div>
    <!-- Side panel -->
    <div id="sidePanel">
      <!-- Side content: two columns (element list and category menu) -->
      <div id="sideContent">
        <!-- Element list scroll area -->
        <div id="elementScroll">
          <div id="toolSearchContainer">
            <input type="text" id="toolSearch" placeholder="Search elements...">
          </div>
          <div id="toolbar">
            <!-- Eraser is FIRST so it's always on top by default. -->
            <div class="tool eraser" data-tool="eraser" data-cat="solids" title="Eraser"><span>Eraser</span></div>
            <!-- Tools -->
            <div class="tool heat" data-tool="heat" data-cat="tools" title="Heat Tool"><span>Heat</span></div>
            <div class="tool cool" data-tool="cool" data-cat="tools" title="Cool Tool"><span>Cool</span></div>
            <div class="tool cook" data-tool="cook" data-cat="tools" title="Cook Tool"><span>Cook</span></div>
            <div class="tool mix" data-tool="mix" data-cat="tools" title="Mix Tool"><span>Mix</span></div>
            <div class="tool move" data-tool="move" data-cat="tools" title="Move Tool"><span>Move</span></div>
            <div class="tool sponge" data-tool="sponge" data-cat="tools" title="Sponge Tool"><span>Sponge</span></div>
            <div class="tool extinguish" data-tool="extinguish" data-cat="tools" title="Extinguish Tool"><span>Ext</span></div>
            <!-- Tools in desired order -->
            <div class="tool sand selected" data-tool="sand" data-cat="powders" title="Sand"><span>S</span></div>
            <div class="tool wall" data-tool="wall" data-cat="solids" title="Wall"><span>Wall</span></div>
            <div class="tool water" data-tool="water" data-cat="liquids" title="Water"><span>W</span></div>
            <div class="tool lava" data-tool="lava" data-cat="liquids" title="Lava"><span>Lv</span></div>
            <div class="tool stone" data-tool="stone" data-cat="solids" title="Stone"><span>St</span></div>
            <div class="tool water-vapor" data-tool="water-vapor" data-cat="gasses" title="Water Vapor"><span>V</span></div>
            <div class="tool copper" data-tool="copper" data-cat="electricity" title="Copper"><span>Cu</span></div>
            <div class="tool steel" data-tool="steel" data-cat="solids" title="Steel"><span>Fe</span></div>
            <div class="tool ice" data-tool="ice" data-cat="solids" title="Ice"><span>I</span></div>
            <div class="tool wood" data-tool="wood" data-cat="solids" title="Wood"><span>Wd</span></div>
            <div class="tool fire" data-tool="fire" data-cat="gasses" title="Fire"><span>F</span></div>
            <div class="tool smoke" data-tool="smoke" data-cat="gasses" title="Smoke"><span>Sm</span></div>
            <div class="tool ash" data-tool="ash" data-cat="powders" title="Ash"><span>A</span></div>
            <div class="tool glass" data-tool="glass" data-cat="solids" title="Glass"><span>G</span></div>
            <div class="tool bomb" data-tool="bomb" data-cat="explosives" title="Bomb"><span>B</span></div>
            <div class="tool dirt" data-tool="dirt" data-cat="powders" title="Dirt"><span>Di</span></div>
            <div class="tool wet-dirt" data-tool="wet-dirt" data-cat="powders" title="Wet Dirt"><span>WDi</span></div>
            <div class="tool wheat-seeds" data-tool="wheat-seeds" data-cat="life" title="Wheat Seeds"><span>WSeeds</span></div>
            <div class="tool flour" data-tool="flour" data-cat="powders,cooking" title="Flour"><span>Flr</span></div>
            <div class="tool dough" data-tool="dough" data-cat="cooking" title="Dough"><span>Dh</span></div>
            <div class="tool bread" data-tool="bread" data-cat="cooking" title="Bread"><span>Br</span></div>
            <div class="tool plant-root" data-tool="plant-root" data-cat="life" title="Plant Roots"><span>PR</span></div>
            <div class="tool spark" data-tool="spark" data-cat="electricity" title="Spark"><span>Sp</span></div>
            <div class="tool oak-seeds" data-tool="oak-seeds" data-cat="life" title="Oak Tree Seeds"><span>OakS</span></div>
            <div class="tool grass" data-tool="grass" data-cat="life" title="Grass"><span>Gr</span></div>
            <div class="tool gas" data-tool="gas" data-cat="gasses" title="Gas"><span>Gas</span></div>
            <!-- cooler & heater -->
            <div class="tool cooler" data-tool="cooler" data-cat="electricity" title="Cooler"><span>CL</span></div>
            <div class="tool heater" data-tool="heater" data-cat="electricity" title="Heater"><span>HT</span></div>
            <!-- Additional Electric Elements -->
            <div class="tool heat-separator" data-tool="heat-separator" data-cat="electricity" title="Heat Separator"><span>HS</span></div>
            <div class="tool input" data-tool="input" data-cat="electricity" title="Input"><span>In</span></div>
            <div class="tool output" data-tool="output" data-cat="electricity" title="Output"><span>Out</span></div>
            <div class="tool not-gate" data-tool="not-gate" data-cat="electricity" title="Not Gate"><span>NOT</span></div>
            <div class="tool and-gate" data-tool="and-gate" data-cat="electricity" title="And Gate"><span>AND</span></div>
            <div class="tool blocker" data-tool="blocker" data-cat="electricity" title="Blocker"><span>Blkr</span></div>
            <!-- Cloner (special) -->
            <div class="tool cloner" data-tool="cloner" data-cat="special" title="Cloner"><span>Cln</span></div>
            <!-- New elements: Coal and Coal Lump -->
            <div class="tool coal" data-tool="coal" data-cat="solids" title="Coal"><span>C</span></div>
            <div class="tool coal-lump" data-tool="coal-lump" data-cat="powders" title="Coal Lump"><span>CLu</span></div>
            <!-- New element: Thermite – assign THERMITE and BURNING_THERMITE (ensure no conflict with mod Orange Juice)
            <div class="tool thermite" data-tool="thermite" data-cat="explosives,powders" title="Thermite"><span>Th</span></div>
            <!-- New elements -->
            <div class="tool acid" data-tool="acid" data-cat="liquids" title="Acid"><span>Acid</span></div>
            <div class="tool slime" data-tool="slime" data-cat="liquids" title="Slime"><span>Slime</span></div>
            <!-- Additional new elements -->
            <div class="tool carbon-dioxide" data-tool="carbon-dioxide" data-cat="gasses" title="Carbon Dioxide"><span>CO2</span></div>
            <div class="tool oxygen" data-tool="oxygen" data-cat="gasses" title="Oxygen"><span>O2</span></div>
            <div class="tool bird" data-tool="bird" data-cat="life" title="Bird"><span>Bird</span></div>
            <div class="tool meat" data-tool="meat" data-cat="cooking" title="Meat"><span>Meat</span></div>
            <div class="tool cooked-meat" data-tool="cooked-meat" data-cat="cooking" title="Cooked Meat"><span>CMeat</span></div>
            <div class="tool cobblestone" data-tool="cobblestone" data-cat="powders" title="Cobblestone"><span>Cbl</span></div>
            <div class="tool oil" data-tool="oil" data-cat="liquids" title="Oil"><span>Oil</span></div>
            <div class="tool thermite" data-tool="thermite" data-cat="powders,explosives" title="Thermite"><span>Th</span></div>
            <div class="tool big-bomb" data-tool="big-bomb" data-cat="explosives" title="Big Bomb"><span>GB</span></div>
            <div class="tool water-bomb" data-tool="water-bomb" data-cat="explosives" title="Water Bomb"><span>WB</span></div>
            <div class="tool nuke-bomb" data-tool="nuke-bomb" data-cat="explosives" title="Nuke Bomb"><span>Nuke</span></div>
          </div>
        </div>
        <!-- Category menu (independent scroll area on the right) -->
        <div id="categoryMenu">
          <button data-category="all" class="selectedCat">All</button>
          <button data-category="tools">Tools</button>
          <button data-category="liquids">Liquids</button>
          <button data-category="powders">Powders</button>
          <button data-category="solids">Solids</button>
          <button data-category="gasses">Gasses</button>
          <button data-category="explosives">Explosives</button>
          <button data-category="life">Life</button>
          <button data-category="cooking">Cooking</button>
          <button data-category="electricity">Electricity Beta</button>
          <button data-category="special">Special</button>
        </div>
      </div>
      <!-- HUD (not scrollable) -->
      <div id="hud">
        <div id="hudTemp">Temp: -- °C</div>
        <div id="hudElem">Element: --</div>
        <div id="hudFPS">FPS: --</div>
      </div>
      <!-- Bottom controls (not scrollable) -->
      <div id="bottomControls">
        <div id="speedContainer">
          <label for="speed">Simulation Speed:</label>
          <input type="range" id="speed" min="0" max="4" step="0.01" value="0.10"/>
          <span id="speedValue">0.10</span>×
        </div>
        <button id="clearAllBtn">Clear All</button>
      </div>
      <!-- Extra Sidebar Buttons -->
      <div id="optionsButtonContainer">
        <button id="optionsButton">Options</button>
      </div>
      <div id="saveLoadButtonContainer">
        <button id="saveLoadButton">Save/Load</button>
      </div>
      <!-- Mod Manager Button -->
      <div id="modButtonContainer">
        <button id="modButton">Mods (Beta)</button>
      </div>
    </div>
  </div>

  <script>
    /***************************************
     * GLOBAL CONSTANTS & ARRAYS
     ***************************************/
    // Stage size is dynamic; default is 50.
    let GRID_SIZE = 50;
    // Tool constants
    const TOOL_HEAT         = 100;
    const TOOL_COOL         = 101;
    const TOOL_COOK         = 102;
    const TOOL_MIX          = 103;
    const TOOL_MOVE         = 104;
    const TOOL_SPONGE       = 105;
    const TOOL_EXTINGUISH   = 106;

    const EMPTY             = 0;
    const ERASER            = 5;
    // Basic elements
    const SAND              = 1;
    const WALL              = 44;
    const WATER             = 2;
    const LAVA              = 3;
    const STONE             = 4;
    const WATER_VAPOR       = 6;
    const CLOUD             = 7;
    const BASALT            = 8;
    const OBSIDIAN          = 9;
    const MOLTEN_SLAG       = 10;
    const COPPER            = 11;
    const STEEL             = 12;
    const ICE               = 13;
    const WOOD              = 14;
    const FIRE              = 15;
    const SMOKE             = 16;
    const BURNING_WOOD      = 17;
    const ASH               = 18;
    const GLASS             = 19;
    const BOMB              = 20;
    // Additional
    const DIRT              = 21;
    const WET_DIRT          = 22;
    const WHEAT_SEEDS       = 23;
    const WHEAT             = 24;
    const FLOUR             = 25;
    const DOUGH             = 26;
    const BREAD             = 27;
    const ROOT              = 28;
    const BURNING_ORGANIC   = 29;
    const SPARK             = 30;
    const CHARGED_COPPER    = 31;
    const OAK_SEEDS         = 32;
    const OAK_LEAVES        = 33;
    const OAK_BABY_LEAVES   = 34;
    const DEAD_OAK          = 35;
    const WET_SAND          = 36;
    const GRASS             = 37;
    const DEAD_PLANT        = 38;
    const BURNING_LEAVES    = 39;
    const BURNING_ROOT      = 40;
    const DEAD_ROOT         = 41;
    const GAS               = 42;
    const BURNING_GAS       = 43;
    const CHARGED_DOWN_COPPER = 45;
    // COOLER & HEATER
    const COOLER            = 46;
    const HEATER            = 47;
    // Electric elements
    const HEAT_SEPARATOR                = 48;
    const CHARGED_HEAT_SEPARATOR        = 49;
    const CHARGED_DOWN_HEAT_SEPARATOR   = 50;
    const INPUT                         = 51;
    const CHARGED_INPUT                 = 52;
    const OUTPUT                        = 53;
    const CHARGED_OUTPUT                = 54;
    const NOT_GATE                      = 55;
    const AND_GATE                      = 56;
    const BLOCKER                       = 57;
    const CHARGED_BLOCKER               = 61;
    // Cloner
    const CLONER                        = 60;
    // New elements: Coal and Coal Lump
    const COAL              = 62;
    const COAL_LUMP         = 63;
    const BURNING_COAL      = 64;
    const BURNING_COAL_LUMP = 65;
    // New element: Thermite – assign THERMITE and BURNING_THERMITE (ensure no conflict with mod Orange Juice)
    const THERMITE          = 68;
    const BURNING_THERMITE  = 69;
    // New elements
    const ACID              = 70;
    const ACID_STEAM        = 71;
    const ACID_CLOUD        = 72;
    const SLIME             = 73;
    // Additional new elements
    const CARBON_DIOXIDE    = 74;
    const OXYGEN            = 75;
    const BIRD             = 76;
    const MEAT             = 77;
    const COOKED_MEAT      = 78;
    const COBBLESTONE      = 79;
    const OIL              = 80;
    const BIG_BOMB         = 81;
    const WATER_BOMB       = 82;
    const FIRE_BOMB        = 83;
    const CRYO_BOMB        = 84;
    const NUKE_BOMB        = 85;
    // Simulation constants
    let speed               = 0.1;
    const simulationTimeStep= 0.1;
    const vaporTransformThreshold= 4;
    const diffusionRate     = 0.3;
    const fireTemperature   = 600;
    const burnDuration      = 1.5;
    const burnToAshChance   = 0.25;
    const fireLifetime      = 2.0;
    const glassTemp         = 1700;
    const bombExplosionRadius= 3;
    const wetDirtEvapTemp   = 100;
    const doughBakeTemp     = 120;
    const breadBurnTemp     = 1000;
    const sparkLifetime     = 0.5;
    const burningGasDuration= 2.0;
    const burnDurationCoal      = 10.0;
    const burnDurationCoalLump  = 5.0;
    // Conduction rates
    const conductionRates = {
      [EMPTY]:0, [SAND]:0.2, [WALL]:0,
      [WATER]:0.9, [LAVA]:0.4, [STONE]:0.05,
      [ERASER]:0, [WATER_VAPOR]:0.6, [CLOUD]:0.3, [BASALT]:0.05, [OBSIDIAN]:0.02,
      [MOLTEN_SLAG]:0.3, [COPPER]:2.0, [STEEL]:0.8, [ICE]:0.3, [WOOD]:0.3,
      [FIRE]:1.0, [SMOKE]:0.3, [BURNING_WOOD]:0.3, [ASH]:0.01, [GLASS]:0.1,
      [BOMB]:0.05, [DIRT]:0.1, [WET_DIRT]:0.15, [WHEAT_SEEDS]:0.05, [WHEAT]:0.05,
      [FLOUR]:0.1, [DOUGH]:0.1, [BREAD]:0.05, [ROOT]:0.1, [BURNING_ORGANIC]:0.3,
      [SPARK]:0.1, [CHARGED_COPPER]:0.1, [OAK_SEEDS]:0.05, [OAK_LEAVES]:0.05,
      [OAK_BABY_LEAVES]:0.05, [DEAD_OAK]:0.05, [WET_SAND]:0.2, [GRASS]:0.1,
      [DEAD_PLANT]:0.05, [BURNING_LEAVES]:0.3, [BURNING_GAS]:0.1, [CHARGED_DOWN_COPPER]:0.05,
      [COOLER]:0.2, [HEATER]:0.2,
      [HEAT_SEPARATOR]:0.2, [CHARGED_HEAT_SEPARATOR]:0.2, [CHARGED_DOWN_HEAT_SEPARATOR]:0.2,
      [INPUT]:0.1, [CHARGED_INPUT]:0.1,
      [OUTPUT]:0.1, [CHARGED_OUTPUT]:0.1,
      [NOT_GATE]:0.1, [AND_GATE]:0.1, [BLOCKER]:0.1,
      [BURNING_ROOT]:0.3, [DEAD_ROOT]:0.1,
      [CHARGED_BLOCKER]:0.1,
      [CLONER]:0.2,
      [COAL]:0.5, [COAL_LUMP]:0.3,
      [BURNING_COAL]:1.0, [BURNING_COAL_LUMP]:1.0,
      [THERMITE]:0.3, [BURNING_THERMITE]:0.5,
      [ACID]:0.8, [ACID_STEAM]:0.6, [ACID_CLOUD]:0.3, [SLIME]:0.4,
      [CARBON_DIOXIDE]:0.2, [OXYGEN]:0.2, [BIRD]:0.1, [MEAT]:0.1, [COOKED_MEAT]:0.1, [COBBLESTONE]:0.1, [OIL]:0.1,
      [BIG_BOMB]:0.05, [WATER_BOMB]:0.05, [FIRE_BOMB]:0.05, [CRYO_BOMB]:0.05, [NUKE_BOMB]:0.05
    };
    const heatCapacities = {
      [EMPTY]:1, [SAND]:1, [WALL]:1,
      [WATER]:1, [LAVA]:1.5, [STONE]:2,
      [ERASER]:1, [WATER_VAPOR]:0.5, [CLOUD]:0.5, [BASALT]:2, [OBSIDIAN]:3,
      [MOLTEN_SLAG]:1.5, [COPPER]:5, [STEEL]:4, [ICE]:2, [WOOD]:1,
      [FIRE]:0.1, [SMOKE]:0.2, [BURNING_WOOD]:1, [ASH]:2, [GLASS]:1,
      [BOMB]:1, [DIRT]:1, [WET_DIRT]:1, [WHEAT_SEEDS]:0.5, [WHEAT]:2,
      [FLOUR]:0.5, [DOUGH]:1, [BREAD]:1, [ROOT]:1, [BURNING_ORGANIC]:0.8,
      [SPARK]:0.1, [CHARGED_COPPER]:0.1, [OAK_SEEDS]:0.5, [OAK_LEAVES]:0.5,
      [OAK_BABY_LEAVES]:0.5, [DEAD_OAK]:0.5, [WET_SAND]:1, [GRASS]:1,
      [DEAD_PLANT]:2, [BURNING_LEAVES]:1, [BURNING_GAS]:0.3, [CHARGED_DOWN_COPPER]:0.1,
      [COOLER]:10, [HEATER]:10,
      [HEAT_SEPARATOR]:2, [CHARGED_HEAT_SEPARATOR]:2, [CHARGED_DOWN_HEAT_SEPARATOR]:2,
      [INPUT]:1, [CHARGED_INPUT]:1,
      [OUTPUT]:1, [CHARGED_OUTPUT]:1,
      [NOT_GATE]:1, [AND_GATE]:1, [BLOCKER]:1,
      [BURNING_ROOT]:1, [DEAD_ROOT]:2,
      [CHARGED_BLOCKER]:1,
      [CLONER]:1,
      [COAL]:1, [COAL_LUMP]:1,
      [BURNING_COAL]:0.1, [BURNING_COAL_LUMP]:0.1,
      [THERMITE]:1, [BURNING_THERMITE]:1.5,
      [ACID]:1, [ACID_STEAM]:0.5, [ACID_CLOUD]:0.5, [SLIME]:2,
      [CARBON_DIOXIDE]:0.5, [OXYGEN]:0.5, [BIRD]:0.5, [MEAT]:0.5, [COOKED_MEAT]:0.5, [COBBLESTONE]:0.5, [OIL]:0.5,
      [BIG_BOMB]:0.05, [WATER_BOMB]:0.05, [FIRE_BOMB]:0.05, [CRYO_BOMB]:0.05, [NUKE_BOMB]:0.05
    };
    // Global arrays for grid state
    let grid = [], temp = [], moved = [];
    let vaporLife = [], cloudLife = [];
    let fireLife = [], smokeLife = [];
    let burningWoodTime = [];
    let wheatHeight = [], wheatMaxHeight = [], seedGrowthTime = [], rootLife = [];
    let sparkLife = [], sparkTimer = [];
    let smokeMaxLife = [], cloudMaxLife = [];
    let branchLevel = [], branchLen = [], branchMaxArr = [], branchSubCount = [];
    let branchDirX = [], branchDirY = [];
    let oakTreeGrowthTime = [], oakTreeHeight = [], oakTreeMaxHeight = [];
    let oakTreeRootTimer = [], oakTreeRootDepth = [], oakTreeRootMax = [];
    let grassStage = [];
    let burningGasTime = [];
    let chargedStateTime = [];
    // Bird movement arrays
    let birdDirections = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(1));
    let birdTimers = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    let birdYMovement = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));

    // New global variable: stroke thickness (in cells)
    let strokeThickness = 1;

    // Game version updated to 0.5.0a
    const currentGameVersion = "0.5.0a";

    // Add these right after the GRID_SIZE declaration and before any functions
    // Global lighting system variables
    window.isDynamicLightingEnabled = false;
    window.lightLevels = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    window.lightColors = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
    window.lightEmitters = {
      [LAVA]: { intensity: 1.0, color: '#ff4500' },
      [FIRE]: { intensity: 0.8, color: '#ffcc00' },
      [BURNING_WOOD]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_ORGANIC]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_LEAVES]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_ROOT]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_COAL]: { intensity: 0.7, color: '#ff4500' },
      [BURNING_COAL_LUMP]: { intensity: 0.7, color: '#ff4500' },
      [BURNING_THERMITE]: { intensity: 1.0, color: '#ffc31f' },
      [BURNING_GAS]: { intensity: 0.5, color: '#ff6666' },
      [CHARGED_COPPER]: { intensity: 0.4, color: '#ff8c00' },
      [CHARGED_DOWN_COPPER]: { intensity: 0.3, color: '#cc6600' },
      [SPARK]: { intensity: 0.9, color: '#ffdd00' },
      [CHARGED_HEAT_SEPARATOR]: { intensity: 0.4, color: '#ffe033' },
      [CHARGED_DOWN_HEAT_SEPARATOR]: { intensity: 0.3, color: '#ffd700' },
      [CHARGED_INPUT]: { intensity: 0.4, color: '#ffff77' },
      [CHARGED_OUTPUT]: { intensity: 0.4, color: '#8888ff' },
      [MOLTEN_SLAG]: { intensity: 0.8, color: '#ff4500' }
    };

    // Function to initialize the grid based on GRID_SIZE.
    function initGrid(newSize) {
      GRID_SIZE = newSize;
      // Update grid DOM: set grid template columns/rows according to new size.
      gridContainer.innerHTML = "";
      gridContainer.appendChild(hoverOverlay);
      gridContainer.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
      gridContainer.style.gridTemplateRows = `repeat(${GRID_SIZE}, 1fr)`;
      // Reset arrays.
      grid = [];
      temp = [];
      moved = [];
      vaporLife = [];
      cloudLife = [];
      fireLife = [];
      smokeLife = [];
      burningWoodTime = [];
      wheatHeight = [];
      wheatMaxHeight = [];
      seedGrowthTime = [];
      rootLife = [];
      sparkLife = [];
      sparkTimer = [];
      smokeMaxLife = [];
      cloudMaxLife = [];
      branchLevel = [];
      branchLen = [];
      branchMaxArr = [];
      branchSubCount = [];
      branchDirX = [];
      branchDirY = [];
      oakTreeGrowthTime = [];
      oakTreeHeight = [];
      oakTreeMaxHeight = [];
      oakTreeRootTimer = [];
      oakTreeRootDepth = [];
      oakTreeRootMax = [];
      grassStage = [];
      burningGasTime = [];
      chargedStateTime = [];
      // Initialize bird arrays
      birdDirections = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(1));
      birdTimers = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
      birdYMovement = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));

      cells.length = 0;
      for (let y = 0; y < GRID_SIZE; y++) {
        let row = [], trow = [], mrow = [];
        let vrow = [], crow = [], frow = [], srow = [], bwrow = [];
        let wH = [], wMH = [], sGT = [], rLifeRow = [];
        let spLifeRow = [], spTimerRow = [];
        let smaxrow = [], cmaxrow = [];
        let bLevel = [], bLen = [], bMax = [], bSub = [], bDirXrow = [], bDirYrow = [];
        let otGrowth = [], otHeight = [], otMaxHeight = [];
        let otRootTimer = [], otRootDepth = [], otRootMax = [];
        let grassRow = [];
        let burnGasRow = [];
        let cdtRow = [];
        for (let x = 0; x < GRID_SIZE; x++) {
          row.push(EMPTY);
          trow.push(null);
          mrow.push(false);
          vrow.push(0);
          crow.push(0);
          frow.push(0);
          srow.push(0);
          bwrow.push(0);
          wH.push(0);
          wMH.push(0);
          sGT.push(0);
          rLifeRow.push(0);
          spLifeRow.push(0);
          spTimerRow.push(0);
          smaxrow.push(1.0 + 2.0 * Math.random());
          cmaxrow.push(5.0 + 5.0 * Math.random());
          bLevel.push(-1);
          bLen.push(0);
          bMax.push(0);
          bSub.push(-1);
          bDirXrow.push(0);
          bDirYrow.push(0);
          otGrowth.push(0);
          otHeight.push(0);
          otMaxHeight.push(0);
          otRootTimer.push(0);
          otRootDepth.push(0);
          otRootMax.push(0);
          grassRow.push(1);
          burnGasRow.push(0);
          cdtRow.push(0);
        }
        grid.push(row);
        temp.push(trow);
        moved.push(mrow);
        vaporLife.push(vrow);
        cloudLife.push(crow);
        fireLife.push(frow);
        smokeLife.push(srow);
        burningWoodTime.push(bwrow);
        wheatHeight.push(wH);
        wheatMaxHeight.push(wMH);
        seedGrowthTime.push(sGT);
        rootLife.push(rLifeRow);
        sparkLife.push(spLifeRow);
        sparkTimer.push(spTimerRow);
        smokeMaxLife.push(smaxrow);
        cloudMaxLife.push(cmaxrow);
        branchLevel.push(bLevel);
        branchLen.push(bLen);
        branchMaxArr.push(bMax);
        branchSubCount.push(bSub);
        branchDirX.push(bDirXrow);
        branchDirY.push(bDirYrow);
        oakTreeGrowthTime.push(otGrowth);
        oakTreeHeight.push(otHeight);
        oakTreeMaxHeight.push(otMaxHeight);
        oakTreeRootTimer.push(otRootTimer);
        oakTreeRootDepth.push(otRootDepth);
        oakTreeRootMax.push(otRootMax);
        grassStage.push(grassRow);
        burningGasTime.push(burnGasRow);
        chargedStateTime.push(cdtRow);
        // Create cell divs.
        let rowOfCells = [];
        for (let x = 0; x < GRID_SIZE; x++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.id = `cell-${x}-${y}`;
          gridContainer.appendChild(cell);
          rowOfCells.push(cell);
        }
        cells.push(rowOfCells);
      }
      
      // Reinitialize lighting arrays when grid size changes
      window.lightLevels = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
      window.lightColors = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
    }
    /***************************************
     * DOM
     ***************************************/
    const gridContainer = document.getElementById('grid');
    const hoverOverlay = document.getElementById('hoverOverlay');
    const toolElements = document.getElementsByClassName('tool');
    const speedSlider = document.getElementById('speed');
    const speedValueDisplay = document.getElementById('speedValue');
    const clearAllBtn = document.getElementById('clearAllBtn');
    const hudTemp = document.getElementById('hudTemp');
    const hudElem = document.getElementById('hudElem');
    const hudFPS = document.getElementById('hudFPS');
    const toolSearch = document.getElementById('toolSearch');
    const toolbar = document.getElementById('toolbar');
    const categoryButtons = document.querySelectorAll('#categoryMenu button');
    let activeCategory = 'all';
    const cells = [];
    // The initGrid function will create the cells.
    initGrid(50); // Default stage size 50x50x50
    let currentTool = SAND;
    function selectTool(el) {
      Array.from(toolElements).forEach(t => t.classList.remove('selected'));
      el.classList.add('selected');
      const name = el.getAttribute('data-tool');
      switch (name) {
        case "eraser": currentTool = ERASER; break;
        case "sand": currentTool = SAND; break;
        case "wall": currentTool = WALL; break;
        case "water": currentTool = WATER; break;
        case "lava": currentTool = LAVA; break;
        case "stone": currentTool = STONE; break;
        case "water-vapor": currentTool = WATER_VAPOR; break;
        case "copper": currentTool = COPPER; break;
        case "steel": currentTool = STEEL; break;
        case "ice": currentTool = ICE; break;
        case "wood": currentTool = WOOD; break;
        case "fire": currentTool = FIRE; break;
        case "smoke": currentTool = SMOKE; break;
        case "ash": currentTool = ASH; break;
        case "glass": currentTool = GLASS; break;
        case "bomb": currentTool = BOMB; break;
        case "dirt": currentTool = DIRT; break;
        case "wet-dirt": currentTool = WET_DIRT; break;
        case "wheat-seeds": currentTool = WHEAT_SEEDS; break;
        case "flour": currentTool = FLOUR; break;
        case "dough": currentTool = DOUGH; break;
        case "bread": currentTool = BREAD; break;
        case "plant-root": currentTool = ROOT; break;
        case "spark": currentTool = SPARK; break;
        case "oak-seeds": currentTool = OAK_SEEDS; break;
        case "grass": currentTool = GRASS; break;
        case "gas": currentTool = GAS; break;
        case "cooler": currentTool = COOLER; break;
        case "heater": currentTool = HEATER; break;
        case "heat-separator": currentTool = HEAT_SEPARATOR; break;
        case "input": currentTool = INPUT; break;
        case "output": currentTool = OUTPUT; break;
        case "not-gate": currentTool = NOT_GATE; break;
        case "and-gate": currentTool = AND_GATE; break;
        case "blocker": currentTool = BLOCKER; break;
        case "cloner": currentTool = CLONER; break;
        case "coal": currentTool = COAL; break;
        case "coal-lump": currentTool = COAL_LUMP; break;
        case "thermite": currentTool = THERMITE; break;
        case "acid": currentTool = ACID; break;
        case "slime": currentTool = SLIME; break;
        case "heat": currentTool = TOOL_HEAT; break;
        case "cool": currentTool = TOOL_COOL; break;
        case "cook": currentTool = TOOL_COOK; break;
        case "mix": currentTool = TOOL_MIX; break;
        case "move": currentTool = TOOL_MOVE; break;
        case "sponge": currentTool = TOOL_SPONGE; break;
        case "extinguish": currentTool = TOOL_EXTINGUISH; break;
        case "thermite": currentTool = THERMITE; break;
        case "acid": currentTool = ACID; break;
        case "slime": currentTool = SLIME; break;
        case "carbon-dioxide": currentTool = CARBON_DIOXIDE; break;
        case "oxygen": currentTool = OXYGEN; break;
        case "bird": currentTool = BIRD; break;
        case "meat": currentTool = MEAT; break;
        case "cooked-meat": currentTool = COOKED_MEAT; break;
        case "cobblestone": currentTool = COBBLESTONE; break;
        case "oil": currentTool = OIL; break;
        case "big-bomb": currentTool = BIG_BOMB; break;
        case "water-bomb": currentTool = WATER_BOMB; break;
        case "fire-bomb": currentTool = FIRE_BOMB; break;
        case "cryo-bomb": currentTool = CRYO_BOMB; break;
        case "nuke-bomb": currentTool = NUKE_BOMB; break;
      }
    }
    Array.from(toolElements).forEach(el => { el.addEventListener('click', () => selectTool(el)); });
    speedSlider.addEventListener('input', e => { speed = parseFloat(e.target.value); speedValueDisplay.textContent = speed.toFixed(2); });
    clearAllBtn.addEventListener('click', () => { for (let y = 0; y < GRID_SIZE; y++) { for (let x = 0; x < GRID_SIZE; x++) { eraseCell(x, y); } } });
    let isLeftMouseDown = false, isRightMouseDown = false;
    let hoveredX = null, hoveredY = null;
    function onMouseDown(e) {
      e.preventDefault();
      if (e.button === 0) isLeftMouseDown = true;
      else if (e.button === 2) isRightMouseDown = true;
    }
    function onMouseUp(e) {
      e.preventDefault();
      if (e.button === 0) isLeftMouseDown = false;
      else if (e.button === 2) isRightMouseDown = false;
    }
    gridContainer.addEventListener('mousedown', onMouseDown);
    gridContainer.addEventListener('mouseup', onMouseUp);
    gridContainer.addEventListener('contextmenu', e => e.preventDefault());
    gridContainer.addEventListener('mouseleave', () => {
      isLeftMouseDown = false;
      isRightMouseDown = false;
      hoveredX = null; hoveredY = null;
      hudTemp.textContent = "Temp: -- °C";
      hudElem.textContent = "Element: --";
      hudFPS.textContent = "FPS: --";
      hoverOverlay.style.display = "none";
    });
    gridContainer.addEventListener('mousemove', e => { const { x, y } = getMousePos(e); hoveredX = x; hoveredY = y; });
    // Listen for scroll (wheel) events to adjust stroke thickness.
    gridContainer.addEventListener('wheel', e => {
      e.preventDefault();
      if (e.deltaY < 0) {
        strokeThickness = Math.min(strokeThickness + 1, 50);
      } else {
        strokeThickness = Math.max(strokeThickness - 1, 1);
      }
    });
    function getMousePos(e) {
      // Use clientWidth to avoid scaling issues.
      const cellSize = gridContainer.clientWidth / GRID_SIZE;
      let rect = gridContainer.getBoundingClientRect();
      let px = Math.floor((e.clientX - rect.left) / cellSize);
      let py = Math.floor((e.clientY - rect.top) / cellSize);
      return { x: Math.max(0, Math.min(GRID_SIZE - 1, px)), y: Math.max(0, Math.min(GRID_SIZE - 1, py)) };
    }
    // Modified spamPlace to place elements over a square area based on strokeThickness.
    function spamPlace() { 
      if (hoveredX === null || hoveredY === null) return; 
      let half = Math.floor(strokeThickness / 2);
      
      // Handle special tools
      if (currentTool >= 100 && currentTool <= 106) {
        if (isLeftMouseDown) {
          for (let dy = -half; dy <= strokeThickness - half - 1; dy++) {
            for (let dx = -half; dx <= strokeThickness - half - 1; dx++) {
              let x = hoveredX + dx, y = hoveredY + dy;
              if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
              
              switch(currentTool) {
                case 100: // TOOL_HEAT
                  if (temp[y][x] !== null) temp[y][x] = Math.min(temp[y][x] + 50, 3000);
                  break;
                case 101: // TOOL_COOL
                  if (temp[y][x] !== null) temp[y][x] = Math.max(temp[y][x] - 50, -271);
                  break;
                case 102: // TOOL_COOK
                  if (grid[y][x] === DOUGH) {
                    grid[y][x] = BREAD;
                    temp[y][x] = 30;
                  }
                  break;
                case 103: // TOOL_MIX
                  if (Math.random() < 0.5) {
                    let dirs = [[1,0], [-1,0], [0,1], [0,-1]];
                    let dir = dirs[Math.floor(Math.random() * dirs.length)];
                    let nx = x + dir[0], ny = y + dir[1];
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                      let tmpElem = grid[y][x];
                      let tmpTemp = temp[y][x];
                      grid[y][x] = grid[ny][nx];
                      temp[y][x] = temp[ny][nx];
                      grid[ny][nx] = tmpElem;
                      temp[ny][nx] = tmpTemp;
                    }
                  }
                  break;
                case 105: // TOOL_SPONGE
                  if ([BURNING_WOOD, BURNING_ORGANIC, BURNING_LEAVES, ASH, FIRE].includes(grid[y][x])) {
                    eraseCell(x, y);
                  }
                  break;
                case 106: // TOOL_EXTINGUISH
                  if (grid[y][x] === FIRE) {
                    eraseCell(x, y);
                  } else if (grid[y][x] === BURNING_WOOD) {
                    grid[y][x] = WOOD;
                    temp[y][x] = 20;
                  } else if (grid[y][x] === BURNING_ORGANIC) {
                    eraseCell(x, y);
                  } else if (grid[y][x] === BURNING_LEAVES) {
                    grid[y][x] = OAK_LEAVES;
                    temp[y][x] = 20;
                  }
                  break;
              }
            }
          }
        }
        return;
      }
      
      // Regular element placement
      for (let dy = -half; dy <= strokeThickness - half - 1; dy++) {
        for (let dx = -half; dx <= strokeThickness - half - 1; dx++) {
          let x = hoveredX + dx, y = hoveredY + dy;
          if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
          if (isLeftMouseDown) {
            placeElementAt(x, y, currentTool);
          } else if (isRightMouseDown) {
            placeElementAt(x, y, ERASER);
          }
        }
      }
    }
    // Update the hover overlay that shows the stroke area.
    function updateHoverOverlay() {
      if (hoveredX === null || hoveredY === null) {
        hoverOverlay.style.display = "none";
        return;
      }
      const cellSize = gridContainer.clientWidth / GRID_SIZE;
      let half = Math.floor(strokeThickness / 2);
      let startX = (hoveredX - half) * cellSize;
      let startY = (hoveredY - half) * cellSize;
      hoverOverlay.style.display = "block";
      hoverOverlay.style.left = startX + "px";
      hoverOverlay.style.top = startY + "px";
      hoverOverlay.style.width = (strokeThickness * cellSize) + "px";
      hoverOverlay.style.height = (strokeThickness * cellSize) + "px";
    }
    /***************************************
     * PLACEMENT & ERASURE
     ***************************************/
    function placeElementAt(x, y, tool) {
      if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
      if (grid[y][x] === tool) return;
      if (tool === ERASER) { eraseCell(x, y); return; }
      eraseCell(x, y);
      grid[y][x] = tool;
      switch (tool) {
        case SAND: temp[y][x] = 20; break;
        case WALL: temp[y][x] = 20; break;
        case WATER: temp[y][x] = 20; break;
        case LAVA: temp[y][x] = 1200; break;
        case STONE: temp[y][x] = 20; break;
        case WATER_VAPOR: temp[y][x] = 120; vaporLife[y][x] = 0; break;
        case COPPER: temp[y][x] = 100; break;
        case STEEL: temp[y][x] = 50; break;
        case ICE: temp[y][x] = -5; break;
        case WOOD: temp[y][x] = 20; burningWoodTime[y][x] = 0; break;
        case FIRE: temp[y][x] = fireTemperature; fireLife[y][x] = 0; break;
        case SMOKE: temp[y][x] = 80; smokeLife[y][x] = 0; smokeMaxLife[y][x] = 1 + 2 * Math.random(); break;
        case BURNING_WOOD: temp[y][x] = 20; break;
        case BURNING_ORGANIC: temp[y][x] = fireTemperature; break;
        case ASH: temp[y][x] = 20; break;
        case GLASS: temp[y][x] = 300; break;
        case BOMB: temp[y][x] = 20; break;
        case DIRT: temp[y][x] = 20; break;
        case WET_DIRT: temp[y][x] = 20; break;
        case WHEAT_SEEDS: temp[y][x] = 20; seedGrowthTime[y][x] = 0; break;
        case FLOUR: temp[y][x] = 20; break;
        case DOUGH: temp[y][x] = 25; break;
        case BREAD: temp[y][x] = 30; break;
        case ROOT: temp[y][x] = 15; break;
        case BURNING_ORGANIC: temp[y][x] = fireTemperature; break;
        case SPARK: temp[y][x] = 20; sparkLife[y][x] = 0; break;
        case CHARGED_COPPER: temp[y][x] = 150; chargedStateTime[y][x] = 0; break;
        case OAK_SEEDS: temp[y][x] = 20; oakTreeGrowthTime[y][x] = 0; break;
        case GRASS: temp[y][x] = 20; grassStage[y][x] = 1; break;
        case GAS: temp[y][x] = 20; break;
        case CHARGED_DOWN_COPPER: temp[y][x] = 150; chargedStateTime[y][x] = 0; break;
        case COOLER: temp[y][x] = 20; break;
        case HEATER: temp[y][x] = 20; break;
        case HEAT_SEPARATOR: temp[y][x] = 20; break;
        case CHARGED_HEAT_SEPARATOR: temp[y][x] = 20; chargedStateTime[y][x] = 0; break;
        case CHARGED_DOWN_HEAT_SEPARATOR: temp[y][x] = 20; chargedStateTime[y][x] = 0; break;
        case INPUT: temp[y][x] = 20; break;
        case CHARGED_INPUT: temp[y][x] = 20; chargedStateTime[y][x] = 0; break;
        case OUTPUT: temp[y][x] = 20; break;
        case CHARGED_OUTPUT: temp[y][x] = 20; chargedStateTime[y][x] = 0; break;
        case NOT_GATE: temp[y][x] = 20; break;
        case AND_GATE: temp[y][x] = 20; break;
        case BLOCKER: temp[y][x] = 20; break;
        case CHARGED_BLOCKER: temp[y][x] = 20; chargedStateTime[y][x] = 0; break;
        case CLONER: temp[y][x] = 20; break;
        case COAL: temp[y][x] = 20; break;
        case COAL_LUMP: temp[y][x] = 20; break;
        case THERMITE: temp[y][x] = 20; break;
        case BURNING_THERMITE: temp[y][x] = 3200; break;
        case ACID: temp[y][x] = 20; break;
        case SLIME: temp[y][x] = 20; break;
        case ACID_STEAM: temp[y][x] = 120; break;
        case ACID_CLOUD: temp[y][x] = 50; break;
        case CARBON_DIOXIDE: temp[y][x] = 20; break;
        case OXYGEN: temp[y][x] = 20; break;
        case BIRD: temp[y][x] = 20; break;
        case MEAT: temp[y][x] = 20; break;
        case COOKED_MEAT: temp[y][x] = 20; break;
        case COBBLESTONE: temp[y][x] = 20; break;
        case OIL: temp[y][x] = 20; break;
        case BIG_BOMB: temp[y][x] = 20; break;
        case WATER_BOMB: temp[y][x] = 20; break;
        case FIRE_BOMB: temp[y][x] = 20; break;
        case CRYO_BOMB: temp[y][x] = 20; break;
        case NUKE_BOMB: temp[y][x] = 20; break;
      }
    }
    function eraseCell(x, y) {
      if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
      grid[y][x] = EMPTY;
      temp[y][x] = null;
      moved[y][x] = false;
      vaporLife[y][x] = 0;
      cloudLife[y][x] = 0;
      fireLife[y][x] = 0;
      smokeLife[y][x] = 0;
      burningWoodTime[y][x] = 0;
      wheatHeight[y][x] = 0;
      wheatMaxHeight[y][x] = 0;
      seedGrowthTime[y][x] = 0;
      rootLife[y][x] = 0;
      sparkLife[y][x] = 0;
      sparkTimer[y][x] = 0;
      oakTreeGrowthTime[y][x] = 0;
      oakTreeHeight[y][x] = 0;
      oakTreeMaxHeight[y][x] = 0;
      oakTreeRootTimer[y][x] = 0;
      oakTreeRootDepth[y][x] = 0;
      oakTreeRootMax[y][x] = 0;
      branchLevel[y][x] = -1;
      branchLen[y][x] = 0;
      branchMaxArr[y][x] = 0;
      branchSubCount[y][x] = -1;
      branchDirX[y][x] = 0;
      branchDirY[y][x] = 0;
      grassStage[y][x] = 1;
      burningGasTime[y][x] = 0;
      chargedStateTime[y][x] = 0;
    }
    /***************************************
     * RENDER & HUD
     ***************************************/
    function renderCell(x, y) {
      const cell = cells[y][x];
      cell.className = 'cell';
      cell.style.opacity = "";
      cell.style.backgroundColor = "";
      const e = grid[y][x];
      
      // Handle base element rendering
      switch (e) {
        case SAND: cell.classList.add('sand'); break;
        case WALL: cell.classList.add('wall'); break;
        case WATER: cell.classList.add('water'); break;
        case LAVA: cell.classList.add('lava'); break;
        case STONE: cell.classList.add('stone'); break;
        case WATER_VAPOR: cell.classList.add('water-vapor'); break;
        case CLOUD: cell.classList.add('cloud'); break;
        case BASALT: cell.classList.add('stone'); break;
        case OBSIDIAN: cell.classList.add('stone'); break;
        case MOLTEN_SLAG: cell.classList.add('lava'); break;
        case COPPER: cell.classList.add('copper'); break;
        case STEEL: cell.classList.add('steel'); break;
        case ICE: cell.classList.add('ice'); break;
        case WOOD: cell.classList.add('wood'); break;
        case FIRE: cell.classList.add('fire'); break;
        case SMOKE: {
          cell.classList.add('smoke');
          let max = smokeMaxLife[y][x];
          let life = smokeLife[y][x];
          let ratio = 1 - (life / max);
          if (ratio < 0) ratio = 0;
          cell.style.opacity = ratio.toString();
        } break;
        case BURNING_WOOD: cell.classList.add('burning-wood'); break;
        case BURNING_ORGANIC: cell.classList.add('burning-organic'); break;
        case ASH: cell.classList.add('ash'); break;
        case GLASS: cell.classList.add('glass'); break;
        case BOMB: cell.classList.add('bomb'); break;
        case DIRT: cell.classList.add('dirt'); break;
        case WET_DIRT: cell.classList.add('wet-dirt'); break;
        case WHEAT_SEEDS: cell.classList.add('wheat-seeds'); break;
        case WHEAT: cell.classList.add('wheat'); break;
        case FLOUR: cell.classList.add('flour'); break;
        case DOUGH: cell.classList.add('dough'); break;
        case BREAD: cell.classList.add('bread'); break;
        case ROOT: cell.classList.add('root'); break;
        case BURNING_ROOT: cell.classList.add('burning-root'); break;
        case DEAD_ROOT: cell.classList.add('dead-root'); break;
        case SPARK: cell.classList.add('spark'); break;
        case CHARGED_COPPER: cell.classList.add('charged-copper'); break;
        case CHARGED_DOWN_COPPER: cell.classList.add('charged-down-copper'); break;
        case OAK_SEEDS: cell.classList.add('oak-seeds'); break;
        case OAK_LEAVES: cell.classList.add('oak-leaves'); break;
        case OAK_BABY_LEAVES: cell.classList.add('oak-baby-leaves'); break;
        case DEAD_OAK: cell.classList.add('dead-oak'); break;
        case WET_SAND: cell.classList.add('wet-sand'); break;
        case GRASS: cell.classList.add('grass'); break;
        case DEAD_PLANT: cell.classList.add('dead-plant'); break;
        case BURNING_LEAVES: cell.classList.add('burning-leaves'); break;
        case GAS: cell.classList.add('gas'); break;
        case BURNING_GAS: cell.classList.add('burning-gas'); break;
        case COOLER: cell.classList.add('cooler'); break;
        case HEATER: cell.classList.add('heater'); break;
        case HEAT_SEPARATOR: cell.classList.add('heat-separator'); break;
        case CHARGED_HEAT_SEPARATOR: cell.classList.add('charged-heat-separator'); break;
        case CHARGED_DOWN_HEAT_SEPARATOR: cell.classList.add('charged-down-heat-separator'); break;
        case INPUT: cell.classList.add('input'); break;
        case CHARGED_INPUT: cell.classList.add('charged-input'); break;
        case OUTPUT: cell.classList.add('output'); break;
        case CHARGED_OUTPUT: cell.classList.add('charged-output'); break;
        case NOT_GATE: cell.classList.add('not-gate'); break;
        case AND_GATE: cell.classList.add('and-gate'); break;
        case BLOCKER: cell.classList.add('blocker'); break;
        case CHARGED_BLOCKER: cell.classList.add('charged-blocker'); break;
        case CLONER: cell.classList.add('cloner'); break;
        case COAL: cell.classList.add('coal'); break;
        case COAL_LUMP: cell.classList.add('coal-lump'); break;
        case THERMITE: cell.classList.add('thermite'); break;
        case BURNING_THERMITE: cell.style.backgroundColor = "#ffc31f"; break;
        case ACID: cell.classList.add('acid'); break;
        case SLIME: cell.classList.add('slime'); break;
        case ACID_STEAM: cell.classList.add('acid-steam'); break;
        case ACID_CLOUD: cell.classList.add('acid-cloud'); break;
        // New elements
        case CARBON_DIOXIDE: cell.classList.add('carbon-dioxide'); break;
        case OXYGEN: cell.classList.add('oxygen'); break;
        case BIRD: cell.classList.add('bird'); break;
        case MEAT: cell.classList.add('meat'); break;
        case COOKED_MEAT: cell.classList.add('cooked-meat'); break;
        case COBBLESTONE: cell.classList.add('cobblestone'); break;
        case OIL: cell.classList.add('oil'); break;
        case BIG_BOMB: cell.classList.add('big-bomb'); break;
        case WATER_BOMB: cell.classList.add('water-bomb'); break;
        case FIRE_BOMB: cell.classList.add('fire-bomb'); break;
        case CRYO_BOMB: cell.classList.add('cryo-bomb'); break;
        case NUKE_BOMB: cell.classList.add('nuke-bomb'); break;
        default: break;
      }
    }
    function renderGrid(){
      for (let y = 0; y < GRID_SIZE; y++){
        for (let x = 0; x < GRID_SIZE; x++){
          renderCell(x, y);
        }
      }
    }
    function updateHUD(){
      if (hoveredX !== null && hoveredY !== null){
        let t = temp[hoveredY][hoveredX];
        let displayT = (t === null) ? "--" : t.toFixed(1);
        hudTemp.textContent = `Temp: ${displayT} °C`;
        hudElem.textContent = `Element: ${getElementName(grid[hoveredY][hoveredX])}`;
      }
    }
    function getElementName(e){
      switch(e){
        case EMPTY: return "Empty";
        case SAND: return "Sand";
        case WALL: return "Wall";
        case WATER: return "Water";
        case LAVA: return "Lava";
        case STONE: return "Stone";
        case ERASER: return "Eraser";
        case WATER_VAPOR: return "Water Vapor";
        case CLOUD: return "Cloud";
        case BASALT: return "Basalt";
        case OBSIDIAN: return "Obsidian";
        case MOLTEN_SLAG: return "Molten Slag";
        case COPPER: return "Copper";
        case STEEL: return "Steel";
        case ICE: return "Ice";
        case WOOD: return "Wood";
        case FIRE: return "Fire";
        case SMOKE: return "Smoke";
        case BURNING_WOOD: return "Burning Wood";
        case BURNING_ORGANIC: return "Burning Organic";
        case ASH: return "Ash";
        case GLASS: return "Glass";
        case BOMB: return "Bomb";
        case DIRT: return "Dirt";
        case WET_DIRT: return "Wet Dirt";
        case WHEAT_SEEDS: return "Wheat Seeds";
        case WHEAT: return "Wheat";
        case FLOUR: return "Flour";
        case DOUGH: return "Dough";
        case BREAD: return "Bread";
        case ROOT: return "Plant Root";
        case BURNING_ROOT: return "Burning Root";
        case DEAD_ROOT: return "Dead Root";
        case SPARK: return "Spark";
        case CHARGED_COPPER: return "Charged Copper";
        case CHARGED_DOWN_COPPER: return "Charged-Down Copper";
        case OAK_SEEDS: return "Oak Tree Seeds";
        case OAK_LEAVES: return "Oak Tree Leaves";
        case OAK_BABY_LEAVES: return "Baby Oak Leaves";
        case DEAD_OAK: return "Dead Oak";
        case WET_SAND: return "Wet Sand";
        case GRASS: return "Grass";
        case DEAD_PLANT: return "Dead Plant";
        case BURNING_LEAVES: return "Burning Leaves";
        case GAS: return "Gas";
        case BURNING_GAS: return "Burning Gas";
        case COOLER: return "Cooler";
        case HEATER: return "Heater";
        case HEAT_SEPARATOR: return "Heat Separator";
        case CHARGED_HEAT_SEPARATOR: return "Charged Heat Separator";
        case CHARGED_DOWN_HEAT_SEPARATOR: return "Charged-Down Heat Separator";
        case INPUT: return "Input";
        case CHARGED_INPUT: return "Charged Input";
        case OUTPUT: return "Output";
        case CHARGED_OUTPUT: return "Charged Output";
        case NOT_GATE: return "Not Gate";
        case AND_GATE: return "And Gate";
        case BLOCKER: return "Blocker";
        case CHARGED_BLOCKER: return "Charged Blocker";
        case CLONER: return "Cloner";
        case COAL: return "Coal";
        case COAL_LUMP: return "Coal Lump";
        case BURNING_COAL: return "Burning Coal";
        case BURNING_COAL_LUMP: return "Burning Coal Lump";
        case THERMITE: return "Thermite";
        case BURNING_THERMITE: return "Molten Thermite";
        case ACID: return "Acid";
        case SLIME: return "Slime";
        case ACID_STEAM: return "Acid Steam";
        case ACID_CLOUD: return "Acid Cloud";
        case CARBON_DIOXIDE: return "Carbon Dioxide";
        case OXYGEN: return "Oxygen";
        case BIRD: return "Bird";
        case MEAT: return "Meat";
        case COOKED_MEAT: return "Cooked Meat";
        case COBBLESTONE: return "Cobblestone";
        case OIL: return "Oil";
        case BIG_BOMB: return "Big Bomb";
        case WATER_BOMB: return "Water Bomb";
        case FIRE_BOMB: return "Fire Bomb";
        case CRYO_BOMB: return "Cryo Bomb";
        case NUKE_BOMB: return "Nuke Bomb";
        default: return "Unknown";
      }
    }
    function resetMoved(){
      for (let y = 0; y < GRID_SIZE; y++){
        for (let x = 0; x < GRID_SIZE; x++){
          moved[y][x] = false;
        }
      }
    }
    /***************************************
     * GAME LOOP
     ***************************************/
    let stepAccumulator = 0;
    let lastTime = performance.now();
    let frames = 0, fps = 0;
    let lastFrameTime = performance.now();
    let fixedTimeStep = 1000 / 60; // Base simulation on 60fps

    function gameLoop(timestamp) {
      frames++;
      const now = performance.now();
      
      // FPS calculation
      if(now - lastTime >= 1000) {
        fps = frames;
        frames = 0;
        lastTime = now;
      }
      hudFPS.textContent = `FPS: ${fps}`;
      
      spamPlace();
      if(speed > 0) {
        // Calculate how much time has passed since last frame
        const deltaTime = timestamp - lastFrameTime;
        lastFrameTime = timestamp;
        
        // Original behavior
        const simulationSteps = speed;
        stepAccumulator += simulationSteps;

        while(stepAccumulator >= 1) {
          resetMoved();
          performSimulationStep();
          updateTemperature();
          unifyCopperClusters();
          processTransformations();
          stepAccumulator -= 1;
        }
      }
      
      updateHUD();
      renderGrid();
      updateHoverOverlay();
      requestAnimationFrame(gameLoop);
    }
    /***************************************
     * SIMULATION STEP
     ***************************************/
    function performSimulationStep(){
      let yPositions = [];
      for (let i = 0; i < GRID_SIZE; i++) yPositions.push(i);
      shuffle(yPositions);
      for (let i = yPositions.length - 1; i >= 0; i--){
        let y = yPositions[i];
        let xPositions = [];
        for (let j = 0; j < GRID_SIZE; j++) xPositions.push(j);
        shuffle(xPositions);
        for (let j = 0; j < xPositions.length; j++){
          let x = xPositions[j];
          if(moved[y][x]) continue;
          let e = grid[y][x];
          if(e === WALL) continue;

          switch(e) {
            case SPARK:
              sparkLife[y][x] += simulationTimeStep;
              if(sparkLife[y][x] >= sparkLifetime){
                eraseCell(x, y);
                continue;
              }
              let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of neighbors){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(grid[ny][nx] === BOMB){
                    explodeBomb(nx, ny);
                  }
                  if(grid[ny][nx] === COPPER && temp[ny][nx] < 300){
                    grid[ny][nx] = CHARGED_COPPER;
                    temp[ny][nx] = Math.min(temp[ny][nx] + 50, 1200);
                    chargedStateTime[ny][nx] = 0;
                  }
                }
              }
              break;

            case SAND:
            case ASH:
            case THERMITE:
            case BOMB:
            case BIG_BOMB:
            case WATER_BOMB:
            case FIRE_BOMB:
            case CRYO_BOMB:
            case NUKE_BOMB:
            case DIRT:
            case WET_DIRT:
            case WHEAT_SEEDS:
            case FLOUR:
            case DEAD_PLANT:
            case GRASS:
            case COAL_LUMP:
            case COBBLESTONE:
              moveLikePowder(x, y, temp[y][x], e);
              break;

            case WET_SAND:
            case DOUGH:
            case BREAD:
              moveNonPowderGravity(x, y, temp[y][x], e);
              break;

            case WATER:
              moveLikeLiquid(x, y, temp[y][x], WATER);
              break;

            case OIL:
              moveOil(x, y, temp[y][x]);
              break;

            case LAVA:
            case MOLTEN_SLAG:
              if(Math.random() < 0.5) continue;
              moveLikeLiquid(x, y, temp[y][x], LAVA);
              break;

            case BURNING_THERMITE:
              moveLikeLiquid(x, y, temp[y][x], THERMITE);
              break;

            case WATER_VAPOR:
              vaporLife[y][x] += simulationTimeStep;
              moveVaporUp(x, y, temp[y][x]);
              break;

            case CLOUD:
              cloudLife[y][x] += simulationTimeStep;
              moveCloud(x, y, temp[y][x]);
              break;

            case FIRE:
              fireLife[y][x] += simulationTimeStep;
              moveFire(x, y, temp[y][x]);
              break;

            case SMOKE:
              smokeLife[y][x] += simulationTimeStep;
              moveSmoke(x, y, temp[y][x]);
              break;

            case GAS:
            case BURNING_GAS:
            case CARBON_DIOXIDE:
            case OXYGEN:
              moveGasElement(x, y, temp[y][x], e);
              break;

            case ACID:
              moveAcid(x, y, temp[y][x]);
              break;

            case SLIME:
              moveSlime(x, y, temp[y][x]);
              break;

            case BIRD:
              moveBird(x, y, temp[y][x]);
              break;

            case MEAT:
            case COOKED_MEAT:
              if (y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]) {
                moveCell(x, y, x, y+1, temp[y][x], e);
              }
              break;
          }
        }
      }
    }
    /***************************************
     * HELPER: shuffle
     ***************************************/
    function shuffle(array){
      for (let i = array.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }
    /***************************************
     * MOVEMENT
     ***************************************/
    function moveCell(x, y, nx, ny, oldT, newElem){
      if(nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) return;
      grid[ny][nx] = newElem;
      temp[ny][nx] = oldT;
      grid[y][x] = EMPTY;
      temp[y][x] = null;
      moved[ny][nx] = true;
      if(newElem === WATER_VAPOR){
        vaporLife[ny][nx] = vaporLife[y][x];
        vaporLife[y][x] = 0;
      }
      if(newElem === ACID_STEAM){
        vaporLife[ny][nx] = vaporLife[y][x];
        vaporLife[y][x] = 0;
      }
      if(newElem === CLOUD){
        cloudLife[ny][nx] = cloudLife[y][x];
        cloudLife[y][x] = 0;
        cloudMaxLife[ny][nx] = cloudMaxLife[y][x];
      }
      if(newElem === FIRE){
        fireLife[ny][nx] = fireLife[y][x];
        fireLife[y][x] = 0;
      }
      if(newElem === SMOKE){
        smokeLife[ny][nx] = smokeLife[y][x];
        smokeLife[y][x] = 0;
        smokeMaxLife[ny][nx] = smokeMaxLife[y][x];
      }
      if(newElem === BURNING_WOOD || newElem === BURNING_ORGANIC || newElem === BURNING_ROOT){
        burningWoodTime[ny][nx] = burningWoodTime[y][x];
        burningWoodTime[y][x] = 0;
      }
      if(newElem === WHEAT_SEEDS){
        seedGrowthTime[ny][nx] = seedGrowthTime[y][x];
        seedGrowthTime[y][x] = 0;
      }
      if(newElem === WHEAT){
        wheatHeight[ny][nx] = wheatHeight[y][x];
        wheatMaxHeight[ny][nx] = wheatMaxHeight[y][x];
        wheatHeight[y][x] = 0;
        wheatMaxHeight[y][x] = 0;
      }
      if(newElem === GAS || newElem === BURNING_GAS){
        burningGasTime[ny][nx] = burningGasTime[y][x];
        burningGasTime[y][x] = 0;
      }
      if(newElem === GRASS){
        grassStage[ny][nx] = grassStage[y][x];
      }
      if(newElem === SPARK){
        sparkLife[ny][nx] = sparkLife[y][x];
        sparkTimer[ny][nx] = sparkTimer[y][x];
        sparkLife[y][x] = 0;
        sparkTimer[y][x] = 0;
      }
      if(newElem === CHARGED_COPPER || newElem === CHARGED_DOWN_COPPER ||
         newElem === CHARGED_HEAT_SEPARATOR || newElem === CHARGED_DOWN_HEAT_SEPARATOR ||
         newElem === CHARGED_INPUT || newElem === CHARGED_OUTPUT ||
         newElem === CHARGED_BLOCKER){
        chargedStateTime[ny][nx] = chargedStateTime[y][x];
        chargedStateTime[y][x] = 0;
      }
    }
    function moveLikePowder(x, y, oldT, elem){
      if(y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]){
        moveCell(x, y, x, y+1, oldT, elem);
      }
      else if(y+1 < GRID_SIZE && (grid[y+1][x] === WATER || grid[y+1][x] === LAVA) && !moved[y+1][x]){
        // Special case for oil floating on water
        if(elem === OIL && grid[y+1][x] === WATER) {
          let tempWater = temp[y+1][x];
          grid[y+1][x] = OIL;
          temp[y+1][x] = oldT;
          grid[y][x] = WATER;
          temp[y][x] = tempWater;
          moved[y+1][x] = true;
          return;
        }

        // For other elements, displace liquid upwards and fall through
        let foundEmpty = false;
        let ny = y;
        while(ny > 0 && !foundEmpty) {
          ny--;
          if(grid[ny][x] === EMPTY) {
            foundEmpty = true;
            break;
          }
        }
        
        if(foundEmpty) {
          // Move liquid up
          let liquidType = grid[y+1][x];
          let liquidTemp = temp[y+1][x];
          grid[ny][x] = liquidType;
          temp[ny][x] = liquidTemp;
          moved[ny][x] = true;
          
          // Move powder down
          grid[y+1][x] = elem;
          temp[y+1][x] = oldT;
          grid[y][x] = EMPTY;
          temp[y][x] = null;
          moved[y+1][x] = true;
        } else {
          // If no empty space found, behave like normal powder
          let diag = [];
          if(x > 0 && y+1 < GRID_SIZE && !moved[y+1][x-1] && grid[y+1][x-1] === EMPTY) diag.push(-1);
          if(x < GRID_SIZE-1 && y+1 < GRID_SIZE && !moved[y+1][x+1] && grid[y+1][x+1] === EMPTY) diag.push(1);
          shuffle(diag);
          for(let d of diag){
            let nx = x + d, ny = y + 1;
            if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
              moveCell(x, y, nx, ny, oldT, elem);
              break;
            }
          }
        }
      }
      else{
        let diag = [];
        if(x > 0 && y+1 < GRID_SIZE && !moved[y+1][x-1] && grid[y+1][x-1] === EMPTY) diag.push(-1);
        if(x < GRID_SIZE-1 && y+1 < GRID_SIZE && !moved[y+1][x+1] && grid[y+1][x+1] === EMPTY) diag.push(1);
        shuffle(diag);
        for(let d of diag){
          let nx = x + d, ny = y + 1;
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, elem);
            break;
          }
        }
      }
    }
    function moveNonPowderGravity(x, y, oldT, elem) {
      if(y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]){
        moveCell(x, y, x, y+1, oldT, elem);
      }
      else if(y+1 < GRID_SIZE && (grid[y+1][x] === WATER || grid[y+1][x] === LAVA) && !moved[y+1][x]){
        // Find empty space above for liquid displacement
        let foundEmpty = false;
        let ny = y;
        while(ny > 0 && !foundEmpty) {
          ny--;
          if(grid[ny][x] === EMPTY) {
            foundEmpty = true;
            break;
          }
        }
        
        if(foundEmpty) {
          // Move liquid up
          let liquidType = grid[y+1][x];
          let liquidTemp = temp[y+1][x];
          grid[ny][x] = liquidType;
          temp[ny][x] = liquidTemp;
          moved[ny][x] = true;
          
          // Move element down
          grid[y+1][x] = elem;
          temp[y+1][x] = oldT;
          grid[y][x] = EMPTY;
          temp[y][x] = null;
          moved[y+1][x] = true;
        }
      }
    }

    function moveLikeLiquid(x, y, oldT, elem){
      // Slow down lava movement
      if(elem === LAVA && Math.random() < 0.5) return;

      if(y+1 < GRID_SIZE && [EMPTY, WATER_VAPOR, CLOUD].includes(grid[y+1][x]) && !moved[y+1][x]){
        let below = grid[y+1][x];
        if(below === CLOUD){
          grid[y+1][x] = elem;
          temp[y+1][x] = oldT;
          grid[y][x] = CLOUD;
          temp[y][x] = 50;
          cloudLife[y][x] = 0;
          moved[y+1][x] = true;
          return;
        }
        else if(below === WATER_VAPOR){
          if(y > 0 && grid[y-1][x] === EMPTY && !moved[y-1][x]){
            grid[y-1][x] = WATER_VAPOR;
            temp[y-1][x] = temp[y+1][x];
            moved[y-1][x] = true;
          }
          moveCell(x, y, x, y+1, oldT, elem);
        }
        else {
          moveCell(x, y, x, y+1, oldT, elem);
        }
      }
      else {
        let dirs = [];
        if(x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
        if(x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
        shuffle(dirs);
        for(let dir of dirs){
          let nx = x + dir, ny = y;
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, elem);
            return;
          }
        }
        let diag = [];
        if(x > 0 && y+1 < GRID_SIZE && grid[y+1][x-1] === EMPTY && !moved[y+1][x-1]) diag.push(-1);
        if(x < GRID_SIZE-1 && y+1 < GRID_SIZE && grid[y+1][x+1] === EMPTY && !moved[y+1][x+1]) diag.push(1);
        shuffle(diag);
        for(let d of diag){
          let nx = x + d, ny = y+1;
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, elem);
            return;
          }
        }
      }
    }
    function moveFire(x, y, oldT){
      let possible = [[0,-1], [-1,-1], [1,-1], [-1,0], [1,0]];
      shuffle(possible);
      for(let [dx, dy] of possible){
        let nx = x + dx, ny = y + dy;
        if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
          if(grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, FIRE);
            break;
          }
        }
      }
    }
    function moveSmoke(x, y, oldT){
      if(y - 1 >= 0 && grid[y-1][x] === EMPTY && !moved[y-1][x]){
        moveCell(x, y, x, y-1, oldT, SMOKE);
      }
      else {
        let dirs = shuffle([-1, 1]);
        for(let dir of dirs){
          let nx = x + dir, ny = y - 1;
          if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, SMOKE);
            break;
          }
        }
      }
    }
    function moveVaporUp(x, y, oldT){
      let ty = y - 1;
      if(ty >= 0){
        if(grid[ty][x] === EMPTY && !moved[ty][x]){
          moveCell(x, y, x, ty, oldT, WATER_VAPOR);
          return;
        }
        else if(grid[ty][x] === WATER && !moved[ty][x]){
          let swpT = temp[ty][x];
          grid[ty][x] = WATER_VAPOR;
          temp[ty][x] = oldT;
          vaporLife[ty][x] = vaporLife[y][x];
          moved[ty][x] = true;
          grid[y][x] = WATER;
          temp[y][x] = swpT;
          return;
        }
      }
      let dirs = shuffle([-1, 1]);
      for(let dir of dirs){
        let nx = x + dir, ny = y - 1;
        if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY && !moved[ny][nx]){
          moveCell(x, y, nx, ny, oldT, WATER_VAPOR);
          return;
        }
      }
    }
    function moveCloud(x, y, oldT){
      if(y - 1 >= 0 && grid[y-1][x] === EMPTY && !moved[y-1][x]){
        moveCell(x, y, x, y-1, oldT, CLOUD);
      }
      else {
        let dirs = shuffle([-1, 1]);
        for(let dir of dirs){
          let nx = x + dir, ny = y - 1;
          if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY && !moved[ny][nx]){
            moveCell(x, y, nx, ny, oldT, CLOUD);
            break;
          }
        }
      }
    }
    function moveGasElement(x, y, oldT, elem){
      let possible = [];
      for(let dy = -1; dy <= 1; dy++){
        for(let dx = -1; dx <= 1; dx++){
          if(dx === 0 && dy === 0) continue;
          let nx = x + dx, ny = y + dy;
          if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY && !moved[ny][nx]){
            possible.push([dx, dy]);
          }
        }
      }
      if(possible.length > 0){
        let [dx, dy] = possible[Math.floor(Math.random() * possible.length)];
        moveCell(x, y, x + dx, y + dy, oldT, elem);
      }
    }
    /***************************************
     * BOMBS & TEMPERATURE
     ***************************************/
    function explodeBomb(cx, cy){
      eraseCell(cx, cy);
      let radius = bombExplosionRadius;
      for(let dy = -radius; dy <= radius; dy++){
        for(let dx = -radius; dx <= radius; dx++){
          let x = cx + dx, y = cy + dy;
          if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if(dist <= radius){
            if(grid[y][x] === BOMB){
              explodeBomb(x, y);
            }
            else {
              if(Math.random() < 0.3){
                eraseCell(x, y);
              }
              else {
                grid[y][x] = FIRE;
                temp[y][x] = fireTemperature;
                fireLife[y][x] = 0;
              }
            }
          }
        }
      }
    }
    function explodeBigBomb(cx, cy){
      eraseCell(cx, cy);
      let radius = bombExplosionRadius * 4; // Double the radius
      for(let dy = -radius; dy <= radius; dy++){
        for(let dx = -radius; dx <= radius; dx++){
          let x = cx + dx, y = cy + dy;
          if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if(dist <= radius){
            if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
               grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
              if(grid[y][x] === BOMB) explodeBomb(x, y);
              else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
              else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
              else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
              else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
              else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
            }
            else {
              if(Math.random() < 0.6){ // Increased chance to erase
                eraseCell(x, y);
              }
              else {
                grid[y][x] = FIRE;
                temp[y][x] = fireTemperature;
                fireLife[y][x] = 0;
          }
        }
      }
    }
  }
}

function explodeWaterBomb(cx, cy){
  eraseCell(cx, cy);
  let radius = bombExplosionRadius;
  for(let dy = -radius; dy <= radius; dy++){
    for(let dx = -radius; dx <= radius; dx++){
      let x = cx + dx, y = cy + dy;
      if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
      let dist = Math.sqrt(dx * dx + dy * dy);
      if(dist <= radius){
        if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
           grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
          if(grid[y][x] === BOMB) explodeBomb(x, y);
          else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
          else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
          else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
          else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
          else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
        }
        else {
          grid[y][x] = WATER;
          temp[y][x] = 20;
        }
      }
    }
  }
}

function explodeFireBomb(cx, cy){
  eraseCell(cx, cy);
  let radius = bombExplosionRadius * 1.5; // Slightly larger radius
  for(let dy = -radius; dy <= radius; dy++){
    for(let dx = -radius; dx <= radius; dx++){
      let x = cx + dx, y = cy + dy;
      if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
      let dist = Math.sqrt(dx * dx + dy * dy);
      if(dist <= radius){
        if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
           grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
          if(grid[y][x] === BOMB) explodeBomb(x, y);
          else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
          else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
          else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
          else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
          else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
        }
        else if(grid[y][x] === EMPTY) {
          // Always place fire in empty cells
          grid[y][x] = FIRE;
          temp[y][x] = fireTemperature * 2; // Hotter fire
          fireLife[y][x] = 0;
        }
        else {
          // For non-empty cells, set them on fire if possible
          let e = grid[y][x];
          if(e === WOOD) {
            grid[y][x] = BURNING_WOOD;
            temp[y][x] = fireTemperature;
            burningWoodTime[y][x] = 0;
          } 
          else if(e === OAK_LEAVES || e === OAK_BABY_LEAVES) {
            grid[y][x] = BURNING_LEAVES;
            temp[y][x] = fireTemperature;
          }
          else {
            // For other elements, just make them very hot
            temp[y][x] = Math.max(temp[y][x] || 0, fireTemperature * 1.5);
          }
        }
      }
    }
  }
}

function explodeCryoBomb(cx, cy){
  eraseCell(cx, cy);
  let radius = bombExplosionRadius;
  for(let dy = -radius; dy <= radius; dy++){
    for(let dx = -radius; dx <= radius; dx++){
      let x = cx + dx, y = cy + dy;
      if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
      let dist = Math.sqrt(dx * dx + dy * dy);
      if(dist <= radius){
        if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
           grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
          if(grid[y][x] === BOMB) explodeBomb(x, y);
          else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
          else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
          else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
          else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
          else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
        }
        else if(grid[y][x] === WATER) {
          grid[y][x] = ICE;
          temp[y][x] = -20;
        }
        else {
          temp[y][x] = -50;
        }
      }
    }
  }
}

function explodeNukeBomb(cx, cy){
  eraseCell(cx, cy);
  let radius = bombExplosionRadius * 25;
  for(let dy = -radius; dy <= radius; dy++){
    for(let dx = -radius; dx <= radius; dx++){
      let x = cx + dx, y = cy + dy;
      if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
      let dist = Math.sqrt(dx * dx + dy * dy);
      if(dist <= radius){
        if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
           grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
          if(grid[y][x] === BOMB) explodeBomb(x, y);
          else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
          else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
          else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
          else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
          else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
        }
        else {
          if(dist < radius / 3) {
            eraseCell(x, y);
          }
          else if(dist < radius * 2/3) {
            grid[y][x] = FIRE;
            temp[y][x] = fireTemperature * 2;
            fireLife[y][x] = 0;
          }
          else {
            if(Math.random() < 0.7) {
              grid[y][x] = FIRE;
              temp[y][x] = fireTemperature;
              fireLife[y][x] = 0;
            }
          }
        }
      }
    }
  }
}
    function unifyCopperClusters(){
      let visited = [];
      for(let y = 0; y < GRID_SIZE; y++){
        visited[y] = [];
        for(let x = 0; x < GRID_SIZE; x++){
          visited[y][x] = false;
        }
      }
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === COPPER && !visited[y][x]){
            let cluster = [], sumT = 0;
            let queue = [[x, y]];
            visited[y][x] = true;
            while(queue.length > 0){
              let [cx, cy] = queue.shift();
              cluster.push([cx, cy]);
              sumT += (temp[cy][cx] || 0);
              for(let [dx, dy] of [[1,0], [-1,0], [0,1], [0,-1]]){
                let nx = cx + dx, ny = cy + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(!visited[ny][nx] && grid[ny][nx] === COPPER){
                    visited[ny][nx] = true;
                    queue.push([nx, ny]);
                  }
                }
              }
            }
            let avg = sumT / cluster.length;
            for(let [cx, cy] of cluster){
              temp[cy][cx] = avg;
            }
          }
        }
      }
    }
    function updateTemperature(){
      let newTemp = [];
      for(let y = 0; y < GRID_SIZE; y++){
        newTemp[y] = [];
        for(let x = 0; x < GRID_SIZE; x++){
          newTemp[y][x] = temp[y][x];
        }
      }
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === EMPTY || temp[y][x] === null){
            newTemp[y][x] = null;
            continue;
          }
          if(e === FIRE){
            newTemp[y][x] = fireTemperature;
            continue;
          }
          let oldT = temp[y][x];
          let wSum = 0, tWeight = 0;
          for(let dy = -1; dy <= 1; dy++){
            for(let dx = -1; dx <= 1; dx++){
              if(dx === 0 && dy === 0) continue;
              let ny = y + dy, nx = x + dx;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx], nt = temp[ny][nx];
                if(ne !== EMPTY && nt !== null){
                  if((e === HEAT_SEPARATOR || e === CHARGED_HEAT_SEPARATOR || e === CHARGED_DOWN_HEAT_SEPARATOR) &&
                     (ne === COPPER || ne === CHARGED_COPPER || ne === CHARGED_DOWN_COPPER)){
                    continue;
                  }
                  if((e === COPPER || e === CHARGED_COPPER || e === CHARGED_DOWN_COPPER) &&
                     (ne === HEAT_SEPARATOR || ne === CHARGED_HEAT_SEPARATOR || ne === CHARGED_DOWN_HEAT_SEPARATOR)){
                    continue;
                  }
                  let cFactor = conductionRates[e] * conductionRates[ne];
                  wSum += cFactor * nt;
                  tWeight += cFactor;
                }
              }
            }
          }
          if(tWeight > 0){
            let avg = wSum / tWeight;
            let cap = heatCapacities[e];
            let myFactor = conductionRates[e] * diffusionRate;
            let delta = myFactor * (avg - oldT) / cap;
            newTemp[y][x] = oldT + delta;
          }
          if(grid[y][x] === BURNING_COAL || grid[y][x] === BURNING_COAL_LUMP){
            let delta = newTemp[y][x] - oldT;
            if(delta > 0) newTemp[y][x] = oldT + delta * 0.1;
            if(newTemp[y][x] > 500) newTemp[y][x] = 500;
          }
        }
      }
      temp = newTemp;
    }
    /***************************************
     * REACTIONS & TRANSFORMS
     ***************************************/
    function processTransformations(){
      transformLavaToRock();
      transformWaterAndLavaToStone();
      transformWaterVapor();
      transformCloudToWater();
      transformIceWater();
      transformFireToSmoke();
      transformBurningWood();
      transformWoodIgnition();
      transformBurningLeaves();
      transformSandToGlass();
      transformDirtWetDirt();
      transformSandWetSand();
      transformFlourToDough();
      transformDoughToBread();
      transformBreadToAshIfHot();
      handleSeedsGrowth();
      handleWheatGrowth();
      handleWheatRootGrowth();
      handleRootsAbsorbWater();
      handleFlammables();
      handleOakTreeGrowth();
      handleOakTreeRootGrowth();
      handleGrassGrowth();
      igniteHotElements();
      triggerBombs();
      transformGas();
      handleBurningGas();
      transformRoots();
      handleChargedCopper();
      handleElectricalElements();
      handleCoolerHeater();
      handleCloners();
      transformThermite();
      transformGrass();
      
      // Handle new elements
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          
          // Handle meat cooking
          if(e === MEAT && temp[y][x] >= doughBakeTemp){
            grid[y][x] = COOKED_MEAT;
            temp[y][x] = 30;
          }
          
          // Handle bird cooking
          if(e === BIRD && temp[y][x] >= doughBakeTemp){
            grid[y][x] = COOKED_MEAT;
            temp[y][x] = 30;
          }
          
          // Handle cobblestone melting
          if(e === COBBLESTONE && temp[y][x] >= 800){
            grid[y][x] = MOLTEN_SLAG;
            temp[y][x] = 1200;
          }
          
          // Handle oil ignition
          if(e === OIL){
            let shouldIgnite = false;
            if(temp[y][x] >= 200) shouldIgnite = true;
            
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx];
                if(ne === FIRE || ne === BURNING_WOOD || ne === BURNING_ORGANIC || 
                   ne === BURNING_LEAVES || ne === BURNING_COAL || ne === BURNING_COAL_LUMP ||
                   ne === BURNING_GAS){  // Added burning gas check
                  shouldIgnite = true;
                  break;
                }
              }
            }
            
            if(shouldIgnite){
              grid[y][x] = BURNING_GAS;
              temp[y][x] = fireTemperature;
              burningGasTime[y][x] = 0;
            }
          }
          
          // Handle Carbon Dioxide transformation
          if(e === CARBON_DIOXIDE){
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx];
                if(ne === WHEAT || ne === GRASS || ne === OAK_LEAVES || 
                   ne === OAK_BABY_LEAVES || ne === WHEAT_SEEDS){
                  grid[y][x] = OXYGEN;
                  temp[y][x] = 20;
                  break;
                }
              }
            }
          }
          
          // Handle Oxygen reactions
          if(e === OXYGEN){
            let shouldIgnite = false;
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            
            // Check for burning elements
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx];
                if(ne === FIRE || ne === BURNING_WOOD || ne === BURNING_ORGANIC || 
                   ne === BURNING_LEAVES || ne === BURNING_COAL || ne === BURNING_COAL_LUMP ||
                   ne === BURNING_GAS){  // Added burning gas check
                  shouldIgnite = true;
                  break;
                }
                // Check for birds (convert to CO2)
                if(ne === BIRD){
                  grid[y][x] = CARBON_DIOXIDE;
                  temp[y][x] = 20;
                  break;
                }
              }
            }
            
            if(shouldIgnite){
              grid[y][x] = FIRE;
              temp[y][x] = 500;
              fireLife[y][x] = 0;
            }
          }
        }
      }
    }
    // New transformation for Thermite:
    function transformThermite(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === THERMITE){
            let ignite = false;
            if(temp[y][x] >= 600) ignite = true;
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx,dy] of neighbors){
              let nx = x+dx, ny = y+dy;
              if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<GRID_SIZE){
                let adj = grid[ny][nx];
                if(adj === SPARK || adj === FIRE || adj === BURNING_THERMITE){
                  ignite = true;
                  break;
                }
              }
            }
            if(ignite){
              grid[y][x] = BURNING_THERMITE;
              temp[y][x] = 3000;
            }
          }
          else if(grid[y][x] === BURNING_THERMITE){
            if(temp[y][x] < 1000){
              grid[y][x] = LAVA;
              temp[y][x] = 1200;
            }
          }
        }
      }
    }
    function igniteFlammable(x, y){
      if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
      let e = grid[y][x];
      if(e === WOOD){
        grid[y][x] = BURNING_WOOD; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
      }
      else if(e === FLOUR || e === WHEAT_SEEDS || e === WHEAT){
        grid[y][x] = BURNING_ORGANIC; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
      }
      else if(e === OAK_LEAVES || e === OAK_BABY_LEAVES){
        grid[y][x] = BURNING_LEAVES; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
      }
      else if(e === GRASS){
        grid[y][x] = BURNING_ORGANIC; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
      }
      else if(e === COAL){
        grid[y][x] = BURNING_COAL; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0;
        temp[y][x] = (temp[y][x] < 100 ? 100 : temp[y][x]);
      }
      else if(e === COAL_LUMP){
        grid[y][x] = BURNING_COAL_LUMP; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0;
        temp[y][x] = (temp[y][x] < 100 ? 100 : temp[y][x]);
      }
    }
    function handleBurningGas(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BURNING_GAS){
            burningGasTime[y][x] += simulationTimeStep;
            let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let e = grid[ny][nx];
                if(e === GAS){
                  grid[ny][nx] = BURNING_GAS; temp[ny][nx] = fireTemperature; burningGasTime[ny][nx] = 0;
                }
                igniteFlammable(nx, ny);
              }
            }
            if(burningGasTime[y][x] >= burningGasDuration){
              grid[y][x] = SMOKE; temp[y][x] = 80; smokeLife[y][x] = 0; smokeMaxLife[y][x] = 1 + 2 * Math.random(); burningGasTime[y][x] = 0;
            }
          }
        }
      }
    }
    function transformGas(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === GAS){
            if(temp[y][x] >= 300){
              grid[y][x] = BURNING_GAS; temp[y][x] = fireTemperature; burningGasTime[y][x] = 0;
            }
            else {
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  let e = grid[ny][nx];
                  if(e === FIRE || e === BURNING_WOOD || e === BURNING_ORGANIC || e === BURNING_LEAVES || e === BURNING_ROOT || e === BURNING_GAS){
                    grid[y][x] = BURNING_GAS; temp[y][x] = fireTemperature; burningGasTime[y][x] = 0; break;
                  }
                }
              }
            }
          }
        }
      }
    }
    function handleSeedsGrowth(){
      for(let y = 0; y < GRID_SIZE - 1; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === WHEAT_SEEDS){
        let below = grid[y+1][x];
            if(below === DIRT || below === WET_DIRT || below === SAND || below === WET_SAND || below === ROOT){
              seedGrowthTime[y][x] += simulationTimeStep;
              if(seedGrowthTime[y][x] >= 3){
                grid[y][x] = WHEAT; temp[y][x] = 20; wheatHeight[y][x] = 1; wheatMaxHeight[y][x] = 2 + Math.floor(Math.random() * 4);
              }
            }
          }
        }
      }
    }
    function handleWheatGrowth(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === WHEAT){
            let h = wheatHeight[y][x], mh = wheatMaxHeight[y][x];
            if(h < mh){
              if(Math.random() < 0.01){
                if(y > 0 && grid[y-1][x] === EMPTY){
                  grid[y-1][x] = WHEAT; temp[y-1][x] = 20; wheatHeight[y-1][x] = h + 1; wheatMaxHeight[y-1][x] = mh;
                }
              }
            }
          }
        }
      }
    }
    function handleWheatRootGrowth(){
      for(let y = 0; y < GRID_SIZE - 1; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === WHEAT){
            for(let depth = 1; depth <= 2; depth++){
              let ny = y + depth;
              if(ny < GRID_SIZE){
                if(grid[ny][x] === EMPTY || grid[ny][x] === DIRT || grid[ny][x] === WET_DIRT || grid[ny][x] === SAND || grid[ny][x] === WET_SAND){
                  if(Math.random() < 0.0005){
                    placeElementAt(x, ny, ROOT);
                  }
                }
                else { break; }
              }
            }
          }
        }
      }
    }
    function handleRootsAbsorbWater(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === ROOT){
            let nb = [[1,0],[-1,0],[0,1],[0,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === WET_DIRT){
                  grid[ny][nx] = DIRT; temp[ny][nx] = 20;
                }
                else if(grid[ny][nx] === WET_SAND){
                  grid[ny][nx] = SAND; temp[ny][nx] = 20;
                }
              }
            }
          }
        }
      }
    }
    function handleFlammables(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BURNING_ORGANIC){
            sparkTimer[y][x] += simulationTimeStep;
            let sparkLimit = 0.2 + 0.1 * Math.random();
            if(sparkTimer[y][x] >= sparkLimit){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              shuffle(nb);
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(grid[ny][nx] === EMPTY){
                    grid[ny][nx] = FIRE; temp[ny][nx] = fireTemperature; fireLife[ny][nx] = 0;
                    break;
                  }
                }
              }
              sparkTimer[y][x] = 0;
            }
            burningWoodTime[y][x] += simulationTimeStep;
            if(burningWoodTime[y][x] >= 1.0){
              let r = Math.random();
              if(r < burnToAshChance){
                grid[y][x] = ASH; temp[y][x] = 50;
              }
              else {
                grid[y][x] = FIRE; temp[y][x] = fireTemperature; fireLife[y][x] = 0;
              }
            }
          }
          else if(grid[y][x] === BURNING_COAL){
            burningWoodTime[y][x] += simulationTimeStep;
            if(Math.random() < 0.1){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              let [dx, dy] = nb[Math.floor(Math.random() * nb.length)];
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY){
                grid[ny][nx] = FIRE; temp[ny][nx] = fireTemperature; fireLife[ny][nx] = 0;
              }
            }
            if(burningWoodTime[y][x] >= burnDurationCoal){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  igniteFlammable(nx, ny);
                }
              }
              grid[y][x] = ASH; temp[y][x] = 50;
            }
          }
          else if(grid[y][x] === BURNING_COAL_LUMP){
            burningWoodTime[y][x] += simulationTimeStep;
            if(Math.random() < 0.1){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              let [dx, dy] = nb[Math.floor(Math.random() * nb.length)];
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY){
                grid[ny][nx] = FIRE; temp[ny][nx] = fireTemperature; fireLife[ny][nx] = 0;
              }
            }
            if(burningWoodTime[y][x] >= burnDurationCoalLump){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  igniteFlammable(nx, ny);
                }
              }
              grid[y][x] = ASH; temp[y][x] = 50;
            }
          }
        }
      }
    }
    function handleOakTreeGrowth(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === OAK_SEEDS){
            if(y === GRID_SIZE - 1){
              grid[y][x] = DEAD_OAK; temp[y][x] = 20;
            }
            else if(![SAND, DIRT, WET_DIRT, WET_SAND].includes(grid[y+1][x])){
              grid[y][x] = DEAD_OAK; temp[y][x] = 20;
            }
            else {
              oakTreeGrowthTime[y][x] += simulationTimeStep;
              if(oakTreeGrowthTime[y][x] >= 15.0){
                grid[y][x] = WOOD; temp[y][x] = 20;
                oakTreeHeight[y][x] = 1;
                oakTreeMaxHeight[y][x] = 10 + Math.floor(Math.random() * 11);
                oakTreeRootTimer[y][x] = 0;
                oakTreeRootDepth[y][x] = 0;
                oakTreeRootMax[y][x] = 8 + Math.floor(Math.random() * 6);
                branchLevel[y][x] = 0;
                branchLen[y][x] = 0;
                branchDirX[y][x] = 0;
                branchDirY[y][x] = 0;
                for(let dy = -1; dy <= 1; dy++){
                  for(let dx = -1; dx <= 1; dx++){
                    let nx = x + dx, ny = y + dy;
                    if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY){
                      grid[ny][nx] = OAK_BABY_LEAVES; temp[ny][nx] = 20;
                    }
                  }
                }
              }
            }
          }
          else if(grid[y][x] === WOOD && branchLevel[y][x] === 0){
            if(oakTreeHeight[y][x] < oakTreeMaxHeight[y][x]){
              if(y > 0 && (grid[y-1][x] === EMPTY || grid[y-1][x] === WOOD || grid[y-1][x] === OAK_LEAVES || grid[y-1][x] === OAK_BABY_LEAVES) && Math.random() < 0.005){
                grid[y-1][x] = WOOD; temp[y-1][x] = 20;
                oakTreeHeight[y-1][x] = oakTreeHeight[y][x] + 1;
                oakTreeMaxHeight[y-1][x] = oakTreeMaxHeight[y][x];
                branchLevel[y-1][x] = 0;
                branchLen[y-1][x] = 0;
                branchDirX[y-1][x] = 0;
                branchDirY[y-1][x] = 0;
              }
            }
          }
          if(grid[y][x] === WOOD && branchLevel[y][x] === 1){
            if(branchLen[y][x] < branchMaxArr[y][x]){
              let branchExtensionProb = 0.0005;
              if(Math.random() < branchExtensionProb){
                let bx = x + branchDirX[y][x], by = y + branchDirY[y][x];
                if(bx >= 0 && bx < GRID_SIZE && by >= 0 && by < GRID_SIZE &&
                   (grid[by][bx] === EMPTY || grid[by][bx] === OAK_LEAVES || grid[by][bx] === OAK_BABY_LEAVES)){
                  grid[by][bx] = WOOD; temp[by][bx] = 20;
                  oakTreeHeight[by][bx] = oakTreeHeight[y][x];
                  oakTreeMaxHeight[by][bx] = oakTreeMaxHeight[y][x];
                  branchLevel[by][bx] = 1;
                  branchLen[by][bx] = branchLen[y][x] + 1;
                  branchMaxArr[by][bx] = branchMaxArr[y][x];
                  branchDirX[by][bx] = branchDirX[y][x];
                  branchDirY[by][bx] = branchDirY[y][x];
                  let leafDirs = [[-1,-1],[0,-1],[1,-1],[-1,0],[1,0]];
                  for(let [ldx, ldy] of leafDirs){
                    let lx = bx + ldx, ly = by + ldy;
                    if(lx >= 0 && lx < GRID_SIZE && ly >= 0 && ly < GRID_SIZE && grid[ly][lx] === EMPTY){
                      grid[ly][lx] = OAK_LEAVES; temp[ly][lx] = 20;
                    }
                  }
                }
              }
            }
          }
          if(grid[y][x] === WOOD && oakTreeHeight[y][x] >= 5 && branchLevel[y][x] === 0){
            if(branchSubCount[y][x] < 1){
              let branchFormationProb = 0.001;
              if(Math.random() < branchFormationProb){
                let branchDirs = [[-1,-1],[1,-1]];
                let chosen = branchDirs[Math.floor(Math.random() * branchDirs.length)];
                let bx = x + chosen[0], by = y + chosen[1];
                if(bx >= 0 && bx < GRID_SIZE && by >= 0 && by < GRID_SIZE &&
                   (grid[by][bx] === EMPTY || grid[by][bx] === OAK_LEAVES || grid[by][bx] === OAK_BABY_LEAVES)){
                  grid[by][bx] = WOOD; temp[by][bx] = 20;
                  oakTreeHeight[by][bx] = oakTreeHeight[y][x];
                  oakTreeMaxHeight[by][bx] = oakTreeMaxHeight[y][x];
                  branchLevel[by][bx] = 1;
                  branchLen[by][bx] = 1;
                  branchMaxArr[by][bx] = (oakTreeHeight[y][x] === 5) ? 1 : (4 + Math.floor(Math.random() * 4));
                  branchDirX[by][bx] = chosen[0];
                  branchDirY[by][bx] = chosen[1];
                  let leafDirs = [[-1,-1],[0,-1],[1,-1],[-1,0],[1,0]];
                  for(let [ldx, ldy] of leafDirs){
                    let lx = bx + ldx, ly = by + ldy;
                    if(lx >= 0 && lx < GRID_SIZE && ly >= 0 && ly < GRID_SIZE && grid[ly][lx] === EMPTY){
                      grid[ly][lx] = OAK_LEAVES; temp[ly][lx] = 20;
                    }
                  }
                  branchSubCount[y][x] = 1;
                }
              }
            }
          }
          if(grid[y][x] === WOOD && oakTreeHeight[y][x] >= 7){
            let sideDirs = [[-1,0],[1,0],[-1,-1],[1,-1]];
            for(let [dx, dy] of sideDirs){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === EMPTY && Math.random() < 0.3){
                  grid[ny][nx] = OAK_LEAVES; temp[ny][nx] = 20;
                }
              }
            }
          }
        }
      }
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === OAK_BABY_LEAVES){
            let remove = false;
            for(let dy = -1; dy <= 1; dy++){
              for(let dx = -1; dx <= 1; dx++){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(grid[ny][nx] === WOOD && oakTreeHeight[ny][nx] >= 5){
                    remove = true; break;
                  }
                }
              }
              if(remove) break;
            }
            if(remove){ eraseCell(x, y); }
          }
        }
      }
    }
    function handleOakTreeRootGrowth(){
      const oakRootGrowthThreshold = 5.0;
      for(let y = 0; y < GRID_SIZE - 1; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === WOOD && oakTreeHeight[y][x] > 0){
            if(oakTreeRootDepth[y][x] < oakTreeRootMax[y][x]){
              oakTreeRootTimer[y][x] += simulationTimeStep;
              if(oakTreeRootTimer[y][x] >= oakRootGrowthThreshold){
                let d = 0;
                while(y + d + 1 < GRID_SIZE && grid[y + d + 1][x] === ROOT){ d++; }
                let targetY = y + d + 1;
                if(targetY < GRID_SIZE && (grid[targetY][x] === EMPTY || grid[targetY][x] === DIRT || grid[targetY][x] === WET_DIRT ||
                   grid[targetY][x] === SAND || grid[targetY][x] === ROOT || grid[targetY][x] === WET_SAND)){
                  placeElementAt(x, targetY, ROOT);
                  oakTreeRootDepth[y][x] += 1;
                }
                if(targetY < GRID_SIZE){
                  if(x - 1 >= 0 && (grid[targetY][x-1] === EMPTY || grid[targetY][x-1] === DIRT || grid[targetY][x-1] === WET_DIRT ||
                     grid[targetY][x-1] === SAND || grid[targetY][x-1] === ROOT || grid[targetY][x-1] === WET_SAND) && Math.random() < 0.3){
                    placeElementAt(x-1, targetY, ROOT);
                  }
                  if(x + 1 < GRID_SIZE && (grid[targetY][x+1] === EMPTY || grid[targetY][x+1] === DIRT || grid[targetY][x+1] === WET_DIRT ||
                     grid[targetY][x+1] === SAND || grid[targetY][x+1] === ROOT || grid[targetY][x+1] === WET_SAND) && Math.random() < 0.3){
                    placeElementAt(x+1, targetY, ROOT);
                  }
                }
                oakTreeRootTimer[y][x] = 0;
              }
            }
          }
        }
      }
    }
    function handleGrassGrowth(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === GRASS){
            let st = grassStage[y][x];
            if(st === 1){
              if(y > 0 && grid[y-1][x] === EMPTY){
                if(Math.random() < 0.0005){
                  grid[y-1][x] = GRASS; grassStage[y-1][x] = 2; temp[y-1][x] = 20;
                }
              }
            }
            let neighbors = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) continue;
              if(grid[ny][nx] === DIRT || grid[ny][nx] === WET_DIRT){
                let ay = ny - 1;
                if(ay >= 0){
                  if(grid[ay][nx] === EMPTY){
                    if(Math.random() < 0.0003){
                      grid[ny][nx] = GRASS; grassStage[ny][nx] = 1; temp[ny][nx] = 20;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    function transformRoots(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === ROOT && temp[y][x] >= 200){
            grid[y][x] = BURNING_ROOT; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
          }
          else if(grid[y][x] === BURNING_ROOT){
            burningWoodTime[y][x] += simulationTimeStep;
            if(burningWoodTime[y][x] >= burnDuration){
              grid[y][x] = DEAD_ROOT; temp[y][x] = 20;
            }
          }
        }
      }
    }
    function igniteHotElements(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let t = temp[y][x];
          if(t !== null && t > 200){
            let e = grid[y][x];
            if(e === WOOD){
              grid[y][x] = BURNING_WOOD; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
            }
            else if(e === FLOUR || e === WHEAT_SEEDS || e === WHEAT){
              grid[y][x] = BURNING_ORGANIC; burningWoodTime[y][x] = 0; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
            }
            else if(e === OAK_LEAVES || e === OAK_BABY_LEAVES){
              grid[y][x] = BURNING_LEAVES; sparkTimer[y][x] = 0; temp[y][x] = fireTemperature;
            }
          }
        }
      }
    }
    function triggerBombs(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BOMB || grid[y][x] === BIG_BOMB || grid[y][x] === WATER_BOMB || 
             grid[y][x] === FIRE_BOMB || grid[y][x] === CRYO_BOMB || grid[y][x] === NUKE_BOMB){
        
        if(temp[y][x] >= 200) {
          if(grid[y][x] === BOMB) explodeBomb(x, y);
          else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
          else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
          else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
          else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
          else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
        }
        
        let neighbors = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
        for(let [dx, dy] of neighbors){
          let nx = x + dx, ny = y + dy;
          if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
            let e = grid[ny][nx];
            if(e === FIRE || e === BURNING_WOOD || e === BURNING_LEAVES || e === BURNING_ORGANIC || e === BURNING_ROOT || e === BURNING_GAS){
              if(grid[y][x] === BOMB) explodeBomb(x, y);
              else if(grid[y][x] === BIG_BOMB) explodeBigBomb(x, y);
              else if(grid[y][x] === WATER_BOMB) explodeWaterBomb(x, y);
              else if(grid[y][x] === FIRE_BOMB) explodeFireBomb(x, y);
              else if(grid[y][x] === CRYO_BOMB) explodeCryoBomb(x, y);
              else if(grid[y][x] === NUKE_BOMB) explodeNukeBomb(x, y);
              break;
            }
          }
        }
      }
    }
  }
}
    function transformLavaToRock(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x], t = temp[y][x];
          if(e === LAVA && t < 600){
            if(Math.random() < 0.5){ grid[y][x] = BASALT; temp[y][x] = 500; }
            else { grid[y][x] = OBSIDIAN; temp[y][x] = 500; }
          }
          if(e === BASALT && t >= 800){ grid[y][x] = LAVA; temp[y][x] = 1200; }
          if(e === OBSIDIAN && t >= 700){ grid[y][x] = MOLTEN_SLAG; temp[y][x] = 1200; }
          if(e === MOLTEN_SLAG && t < 800){ grid[y][x] = OBSIDIAN; temp[y][x] = 600; }
        }
      }
    }
    function transformWaterAndLavaToStone(){
      let cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === WATER || e === LAVA){
            for(let dy = -1; dy <= 1; dy++){
              for(let dx = -1; dx <= 1; dx++){
                let ny = y + dy, nx = x + dx;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if((e === WATER && grid[ny][nx] === LAVA) || (e === LAVA && grid[ny][nx] === WATER)){
                    cpy[y][x] = STONE; temp[y][x] = 20;
                    cpy[ny][nx] = STONE; temp[ny][nx] = 20;
                  }
                }
              }
            }
          }
        }
      }
      grid = cpy;
    }
    function transformWaterVapor(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === WATER){
            if(temp[y][x] >= 100){
              grid[y][x] = WATER_VAPOR; temp[y][x] = 120; vaporLife[y][x] = 0;
            }
          }
          else if(grid[y][x] === WATER_VAPOR){
            if(vaporLife[y][x] >= vaporTransformThreshold || vaporLife[y][x] >= 6){
              let count = 0;
              for(let dy = -1; dy <= 1; dy++){
                for(let dx = -1; dx <= 1; dx++){
                  let ny = y + dy, nx = x + dx;
                  if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                    if(grid[ny][nx] === WATER_VAPOR && vaporLife[ny][nx] >= vaporTransformThreshold){
                      count++;
                    }
                  }
                }
              }
              if(count >= 3 || vaporLife[y][x] >= 6){
                grid[y][x] = CLOUD; temp[y][x] = 50; cloudLife[y][x] = 0;
              }
            }
          }
        }
      }
    }
    function transformCloudToWater(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CLOUD){
            if(temp[y][x] < 10){ grid[y][x] = WATER; temp[y][x] = 20; }
            else if(cloudLife[y][x] >= cloudMaxLife[y][x]){ grid[y][x] = WATER; temp[y][x] = 20; cloudLife[y][x] = 0; }
          }
        }
      }
    }
    function transformIceWater(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x], t = temp[y][x];
          if(e === WATER && t < 0){ grid[y][x] = ICE; temp[y][x] = -5; }
          else if(e === ICE && t > 2){ grid[y][x] = WATER; temp[y][x] = 5; }
        }
      }
    }
    function transformFireToSmoke(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === FIRE){
            if(fireLife[y][x] >= fireLifetime){
              grid[y][x] = SMOKE; temp[y][x] = 80; smokeLife[y][x] = 0; smokeMaxLife[y][x] = 1 + 2 * Math.random();
            }
            else { temp[y][x] = fireTemperature; }
          }
          else if(grid[y][x] === SMOKE){
            if(smokeLife[y][x] >= smokeMaxLife[y][x]){ eraseCell(x, y); }
          }
        }
      }
    }
    function transformBurningWood(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BURNING_WOOD){
            sparkTimer[y][x] += simulationTimeStep;
            let sparkLimit = 0.2 + 0.1 * Math.random();
            if(sparkTimer[y][x] >= sparkLimit){
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              shuffle(nb);
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(grid[ny][nx] === EMPTY){
                    grid[ny][nx] = FIRE; temp[ny][nx] = fireTemperature; fireLife[ny][nx] = 0;
                    break;
                  }
                }
              }
              sparkTimer[y][x] = 0;
            }
            burningWoodTime[y][x] += simulationTimeStep;
            if(burningWoodTime[y][x] >= burnDuration){
              let r = Math.random();
              let newElem = (r < burnToAshChance) ? ASH : FIRE;
              grid[y][x] = newElem;
              if(newElem === FIRE){ temp[y][x] = fireTemperature; fireLife[y][x] = 0; }
              else { temp[y][x] = 50; }
            }
          }
        }
      }
    }
    function transformWoodIgnition(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === FIRE){
            let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let e = grid[ny][nx];
                if(e === WOOD){
                  grid[ny][nx] = BURNING_WOOD; burningWoodTime[ny][nx] = 0; sparkTimer[ny][nx] = 0; temp[ny][nx] = 100;
                }
                if(e === OAK_LEAVES || e === OAK_BABY_LEAVES){
                  grid[ny][nx] = BURNING_LEAVES; sparkTimer[ny][nx] = 0; temp[ny][nx] = fireTemperature;
                }
                if(e === COAL){
                  grid[ny][nx] = BURNING_COAL; burningWoodTime[ny][nx] = 0; sparkTimer[ny][nx] = 0;
                  temp[ny][nx] = (temp[ny][nx] < 100 ? 100 : temp[ny][nx]);
                }
                if(e === COAL_LUMP){
                  grid[ny][nx] = BURNING_COAL_LUMP; burningWoodTime[ny][nx] = 0; sparkTimer[ny][nx] = 0;
                  temp[ny][nx] = (temp[ny][nx] < 100 ? 100 : temp[ny][nx]);
                }
              }
            }
          }
        }
      }
    }
    function transformBurningLeaves(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BURNING_LEAVES){
            sparkTimer[y][x] += simulationTimeStep;
            if(sparkTimer[y][x] >= burnDuration){
              let r = Math.random();
              let newElem = (r < 0.5) ? DEAD_PLANT : FIRE;
              grid[y][x] = newElem;
              if(newElem === FIRE){ temp[y][x] = fireTemperature; fireLife[y][x] = 0; }
              else { temp[y][x] = 20; }
              let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  let en = grid[ny][nx];
                  if(en === WOOD || en === OAK_LEAVES || en === OAK_BABY_LEAVES){
                    if(en === WOOD){
                      grid[ny][nx] = BURNING_WOOD; burningWoodTime[ny][nx] = 0; sparkTimer[ny][nx] = 0; temp[ny][nx] = fireTemperature;
                    }
                    else {
                      grid[ny][nx] = BURNING_LEAVES; sparkTimer[ny][nx] = 0; temp[ny][nx] = fireTemperature;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    function transformSandToGlass(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === SAND && temp[y][x] >= glassTemp){
            grid[y][x] = GLASS; temp[y][x] = 300;
          }
        }
      }
    }
    function transformDirtWetDirt(){
      let cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === DIRT){
            let nb = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === WATER){
                  cpy[y][x] = WET_DIRT; temp[y][x] = 20;
                  cpy[ny][nx] = EMPTY; temp[ny][nx] = null;
                  break;
                }
              }
            }
          }
          else if(e === WET_DIRT){
            if(temp[y][x] >= wetDirtEvapTemp){
              cpy[y][x] = DIRT; temp[y][x] = 20;
            }
            else {
              let foundWater = null, foundDirt = null;
              let nb = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
              for(let [dx, dy] of nb){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  if(grid[ny][nx] === WATER) foundWater = [nx, ny];
                  if(grid[ny][nx] === DIRT) foundDirt = [nx, ny];
                }
              }
              if(foundWater && foundDirt){
                let [wx, wy] = foundWater, [dx2, dy2] = foundDirt;
                cpy[dy2][dx2] = WET_DIRT; temp[dy2][dx2] = 20;
                cpy[wy][wx] = EMPTY; temp[wy][wx] = null;
              }
            }
          }
        }
      }
      grid = cpy;
    }
    function transformSandWetSand(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === SAND){
            let nb = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === WATER){
                  grid[y][x] = WET_SAND; temp[y][x] = 20;
                  break;
                }
              }
            }
          }
          else if(grid[y][x] === WET_SAND){
            if(temp[y][x] >= wetDirtEvapTemp){
              grid[y][x] = SAND; temp[y][x] = 20;
            }
          }
        }
      }
    }
    function transformFlourToDough(){
      let cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === FLOUR){
            let nb = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of nb){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === WATER){
                  cpy[y][x] = DOUGH; temp[y][x] = 25;
                  cpy[ny][nx] = EMPTY; temp[ny][nx] = null;
                  break;
                }
              }
            }
          }
        }
      }
      grid = cpy;
    }
    function transformDoughToBread(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === DOUGH && temp[y][x] >= doughBakeTemp){
            grid[y][x] = BREAD; temp[y][x] = 30;
          }
        }
      }
    }
    function transformBreadToAshIfHot(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === BREAD && temp[y][x] >= breadBurnTemp){
            grid[y][x] = ASH; temp[y][x] = 50;
          }
        }
      }
    }
    function handleChargedCopper(){
      let cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CHARGED_COPPER){
            if(temp[y][x] >= 300){
              cpy[y][x] = COPPER;
              chargedStateTime[y][x] = 0;
              continue;
            }
            let adj = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of adj){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(cpy[ny][nx] === COPPER && temp[ny][nx] < 300){
                  cpy[ny][nx] = CHARGED_COPPER;
                  temp[ny][nx] = Math.min(temp[ny][nx] + 50, 1200);
                  chargedStateTime[ny][nx] = 0;
                }
              }
            }
            cpy[y][x] = CHARGED_DOWN_COPPER;
            chargedStateTime[y][x] = 0;
          }
        }
      }
      grid = cpy;
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === CHARGED_COPPER){
            if(temp[y][x] >= 300){
              grid[y][x] = COPPER; chargedStateTime[y][x] = 0; continue;
            }
            chargedStateTime[y][x] += simulationTimeStep;
            let anyCopper = false;
            let adj = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of adj){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === COPPER && temp[ny][nx] < 300){ anyCopper = true; break; }
              }
            }
            if(!anyCopper || chargedStateTime[y][x] >= 1.0){
              grid[y][x] = CHARGED_DOWN_COPPER;
              chargedStateTime[y][x] = 0;
            }
          }
          else if(e === CHARGED_DOWN_COPPER){
            chargedStateTime[y][x] += simulationTimeStep;
            if(chargedStateTime[y][x] >= 1.0){
              grid[y][x] = COPPER;
              chargedStateTime[y][x] = 0;
            }
          }
        }
      }
    }
    function handleElectricalElements(){
      let cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CHARGED_HEAT_SEPARATOR){
            let adj = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx, dy] of adj){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(cpy[ny][nx] === HEAT_SEPARATOR && temp[ny][nx] < 300){
                  cpy[ny][nx] = CHARGED_HEAT_SEPARATOR;
                  temp[ny][nx] = Math.min(temp[ny][nx] + 50, 1200);
                  chargedStateTime[ny][nx] = 0;
                }
                if(cpy[ny][nx] === COPPER && temp[ny][nx] < 300){
                  cpy[ny][nx] = CHARGED_COPPER;
                  temp[ny][nx] = Math.min(temp[ny][nx] + 50, 1200);
                  chargedStateTime[ny][nx] = 0;
                }
              }
            }
            cpy[y][x] = CHARGED_DOWN_HEAT_SEPARATOR;
            chargedStateTime[y][x] = 0;
          }
        }
      }
      grid = cpy;
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === CHARGED_HEAT_SEPARATOR){
            chargedStateTime[y][x] += simulationTimeStep;
            if(chargedStateTime[y][x] >= 1.0){ grid[y][x] = CHARGED_DOWN_HEAT_SEPARATOR; chargedStateTime[y][x] = 0; }
          }
          else if(e === CHARGED_DOWN_HEAT_SEPARATOR){
            chargedStateTime[y][x] += simulationTimeStep;
            if(chargedStateTime[y][x] >= 1.0){ grid[y][x] = HEAT_SEPARATOR; chargedStateTime[y][x] = 0; }
          }
        }
      }
      cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === INPUT){
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            let shouldCharge = false;
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx];
                if(ne === CHARGED_COPPER || ne === CHARGED_DOWN_COPPER){ shouldCharge = true; break; }
              }
            }
            if(shouldCharge){ cpy[y][x] = CHARGED_INPUT; chargedStateTime[y][x] = 0; }
            else { cpy[y][x] = INPUT; }
          }
        }
      }
      grid = cpy;
      cpy = grid.map(r => r.slice());
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === OUTPUT){
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            let doCharge = false;
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let ne = grid[ny][nx];
                if(ne === CHARGED_HEAT_SEPARATOR || ne === CHARGED_DOWN_HEAT_SEPARATOR ||
                   ne === CHARGED_OUTPUT || ne === CHARGED_BLOCKER || ne === NOT_GATE || ne === AND_GATE){
                  doCharge = true; break;
                }
              }
            }
            if(doCharge){ cpy[y][x] = CHARGED_OUTPUT; chargedStateTime[y][x] = chargedStateTime[y][x] || 0; }
          }
        }
      }
      grid = cpy;
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CHARGED_OUTPUT){
            chargedStateTime[y][x] += simulationTimeStep;
            if(chargedStateTime[y][x] >= 3.0){
              grid[y][x] = OUTPUT; chargedStateTime[y][x] = 0;
            }
          }
        }
      }
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CHARGED_INPUT){
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            let stillCharged = false;
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === CHARGED_COPPER || grid[ny][nx] === CHARGED_DOWN_COPPER){ stillCharged = true; break; }
              }
            }
            if(!stillCharged){ grid[y][x] = INPUT; }
          }
        }
      }
    }
    function handleCoolerHeater(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          let e = grid[y][x];
          if(e === COOLER || e === HEATER){
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            let hasChargedInput = false;
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                if(grid[ny][nx] === CHARGED_INPUT){ hasChargedInput = true; break; }
              }
            }
            if(!hasChargedInput) continue;
            for(let [dx, dy] of neighbors){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let e2 = grid[ny][nx];
                if(e2 === CHARGED_COPPER || e2 === CHARGED_DOWN_COPPER){
                  if(e === COOLER){ temp[ny][nx] = Math.max(temp[ny][nx] - 100 * simulationTimeStep, -1000); }
                  else { temp[ny][nx] = Math.min(temp[ny][nx] + 100 * simulationTimeStep, 3000); }
                }
              }
            }
          }
        }
      }
    }
    function handleCloners(){
      let replication = [];
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === CLONER){
            let directions = [[0,-1],[0,1],[-1,0],[1,0]];
            let foundOccupants = [];
            for(let [dx, dy] of directions){
              let nx = x + dx, ny = y + dy;
              if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                let e = grid[ny][nx];
                if(e !== EMPTY && e !== CLONER){
                  foundOccupants.push({ ox: nx, oy: ny });
                }
              }
            }
            if(foundOccupants.length > 0){
              for(let occupant of foundOccupants){
                let ex = occupant.ox, ey = occupant.oy;
                for(let [dx2, dy2] of directions){
                  let rx = x + dx2, ry = y + dy2;
                  if(rx === ex && ry === ey) continue;
                  if(rx >= 0 && rx < GRID_SIZE && ry >= 0 && ry < GRID_SIZE){
                    if(grid[ry][rx] === EMPTY){
                      replication.push({ srcX: ex, srcY: ey, dstX: rx, dstY: ry });
                    }
                  }
                }
              }
            }
          }
        }
      }
      for(let rep of replication){
        let sX = rep.srcX, sY = rep.srcY;
        let dX = rep.dstX, dY = rep.dstY;
        if(grid[dY][dX] !== EMPTY) continue;
        cloneCell(sX, sY, dX, dY);
      }
    }
    function cloneCell(sx, sy, dx, dy){
      let occupant = grid[sy][sx];
      grid[dy][dx] = occupant;
      temp[dy][dx] = temp[sy][sx];
      if(occupant === WATER_VAPOR){ vaporLife[dy][dx] = vaporLife[sy][sx]; }
      if(occupant === CLOUD){ cloudLife[dy][dx] = cloudLife[sy][sx]; cloudMaxLife[dy][dx] = cloudMaxLife[sy][dx]; }
      if(occupant === FIRE){ fireLife[dy][dx] = fireLife[sy][sx]; }
      if(occupant === SMOKE){ smokeLife[dy][dx] = smokeLife[sy][sx]; smokeMaxLife[dy][dx] = smokeMaxLife[sy][sx]; }
      if(occupant === BURNING_WOOD || occupant === BURNING_ORGANIC || occupant === BURNING_ROOT){ burningWoodTime[dy][dx] = burningWoodTime[sy][sx]; }
      if(occupant === WHEAT_SEEDS){ seedGrowthTime[dy][dx] = seedGrowthTime[sy][sx]; }
      if(occupant === WHEAT){ wheatHeight[dy][dx] = wheatHeight[sy][sx]; wheatMaxHeight[dy][dx] = wheatMaxHeight[sy][sx]; }
      if(occupant === GAS || occupant === BURNING_GAS){ burningGasTime[dy][dx] = burningGasTime[sy][sx]; }
      if(occupant === GRASS){ grassStage[dy][dx] = grassStage[sy][sx]; }
      if(occupant === SPARK){ sparkLife[dy][dx] = sparkLife[sy][sx]; sparkTimer[dy][dx] = sparkTimer[sy][sx]; }
      if(occupant === CHARGED_COPPER || occupant === CHARGED_DOWN_COPPER ||
         occupant === CHARGED_HEAT_SEPARATOR || occupant === CHARGED_DOWN_HEAT_SEPARATOR ||
         occupant === CHARGED_INPUT || occupant === CHARGED_OUTPUT || occupant === CHARGED_BLOCKER){
        chargedStateTime[dy][dx] = chargedStateTime[sy][dx];
      }
    }
    /*******************************************
     * New Transformation: Thermite
     *******************************************/
    function transformThermite(){
      for(let y = 0; y < GRID_SIZE; y++){
        for(let x = 0; x < GRID_SIZE; x++){
          if(grid[y][x] === THERMITE){
            let ignite = false;
            if(temp[y][x] >= 600) ignite = true;
            let nb = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for(let [dx,dy] of nb){
              let nx = x+dx, ny = y+dy;
              if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<GRID_SIZE){
                let adj = grid[ny][nx];
                if(adj === SPARK || adj === FIRE || adj === BURNING_THERMITE){
                  ignite = true;
                  break;
                }
              }
            }
            if(ignite){
              grid[y][x] = BURNING_THERMITE;
              temp[y][x] = 3000;
            }
          }
          else if(grid[y][x] === BURNING_THERMITE){
            if(temp[y][x] < 1000){
              grid[y][x] = LAVA;
              temp[y][x] = 1200;
            }
          }
        }
      }
    }
    /*******************************************
     * CATEGORY / SEARCH FILTERING
     *******************************************/
    categoryButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        categoryButtons.forEach(b => b.classList.remove('selectedCat'));
        btn.classList.add('selectedCat');
        activeCategory = btn.getAttribute('data-category');
        filterTools();
      });
    });
    toolSearch.addEventListener('input', filterTools);
    function filterTools(){
      const searchVal = toolSearch.value.trim().toLowerCase();
      
      Array.from(toolElements).forEach(tool => {
        const toolName = tool.getAttribute('data-tool') || '';
        const cats = (tool.getAttribute('data-cat') || '').toLowerCase().split(',');
        
        // Tools only show in tools tab
        let inCat = (activeCategory === 'all' && !cats.includes('tools')) || cats.includes(activeCategory);
        let inSearch = !searchVal || toolName.toLowerCase().includes(searchVal);
        
        tool.style.display = (inCat && inSearch) ? 'flex' : 'none';
      });
    }
    filterTools();

    // Add acid and slime movement functions
    function moveAcid(x, y, oldT) {
      if (y+1 < GRID_SIZE && [EMPTY, WATER_VAPOR, CLOUD].includes(grid[y+1][x]) && !moved[y+1][x]) {
        moveCell(x, y, x, y+1, oldT, ACID);
      } else {
        let dirs = [];
        if (x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
        if (x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
        shuffle(dirs);
        for (let dir of dirs) {
          let nx = x + dir;
          if (grid[y][nx] === EMPTY && !moved[y][nx]) {
            moveCell(x, y, nx, y, oldT, ACID);
            return;
          }
        }
        
        // Destroy adjacent non-cloner elements with updated behavior
        let neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
        for (let [dx, dy] of neighbors) {
          let nx = x + dx, ny = y + dy;
          if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
            if (grid[ny][nx] !== EMPTY && grid[ny][nx] !== ACID && 
                grid[ny][nx] !== CLONER && grid[ny][nx] !== ACID_STEAM && 
                grid[ny][nx] !== ACID_CLOUD) {
              if (Math.random() < 0.1) {
                eraseCell(nx, ny);
                // 1/4 chance to delete itself when deleting another element
                if (Math.random() < 0.25) {
                  eraseCell(x, y);
            return;
          }
        }
      }
    }
        }
        
        // Evaporation
        if (temp[y][x] >= 100 && Math.random() < 0.1) {
          grid[y][x] = ACID_STEAM;
          temp[y][x] = 120;
        }
      }
    }

    function moveSlime(x, y, oldT) {
      if (Math.random() < 0.1) { // Very slow movement
        if (y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]) {
          moveCell(x, y, x, y+1, oldT, SLIME);
        } else {
          let dirs = [];
          if (x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
          if (x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
          shuffle(dirs);
          for (let dir of dirs) {
            let nx = x + dir;
            if (grid[y][nx] === EMPTY && !moved[y][nx]) {
              moveCell(x, y, nx, y, oldT, SLIME);
              return;
            }
          }
        }
      }
    }

    // Add to conductionRates
    conductionRates[ACID] = 0.8;
    conductionRates[ACID_STEAM] = 0.6;
    conductionRates[ACID_CLOUD] = 0.3;
    conductionRates[SLIME] = 0.4;

    // Add to heatCapacities
    heatCapacities[ACID] = 1;
    heatCapacities[ACID_STEAM] = 0.5;
    heatCapacities[ACID_CLOUD] = 0.5;
    heatCapacities[SLIME] = 2;

    function transformGrass() {
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === GRASS) {
            // Check temperature
            if (temp[y][x] >= 200) {
              grid[y][x] = BURNING_ORGANIC;
              temp[y][x] = fireTemperature;
              burningWoodTime[y][x] = 0;
            }
            // Check for nearby fire
            let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for (let [dx, dy] of neighbors) {
              let nx = x + dx, ny = y + dy;
              if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                if (grid[ny][nx] === FIRE || grid[ny][nx] === BURNING_ORGANIC) {
                  grid[y][x] = BURNING_ORGANIC;
                  temp[y][x] = fireTemperature;
                  burningWoodTime[y][x] = 0;
                  break;
                }
              }
            }
          }
        }
      }
    }

    // Initialize debug elements after DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      const debugTab = document.querySelector('button[data-category="debug"]');
      if (debugTab) debugTab.style.display = 'none';
      
      const debugElements = document.querySelectorAll('.tool[data-cat*="debug"]');
      debugElements.forEach(elem => {
        elem.style.display = 'none';
      });

      // Add downloadOfflineBtn event listener here
      const downloadOfflineBtn = document.getElementById('downloadOfflineBtn');
      if (downloadOfflineBtn) {
        downloadOfflineBtn.addEventListener('click', function() {
          const htmlContent = document.documentElement.outerHTML;
          const blob = new Blob([htmlContent], { type: 'text/html' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'sandbox_game.html';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        });
      }
    });

    // Add to global variables
    let targetFps = 0;
    let popOutWindow = null;

    // Add event handlers
    document.getElementById('downloadOfflineBtn').addEventListener('click', function() {
      const htmlContent = document.documentElement.outerHTML;
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'sandbox_game.html';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    document.getElementById('dabyFps').addEventListener('change', function(e) {
      targetFps = parseInt(e.target.value);
    });

    document.getElementById('popOutMode').addEventListener('change', function(e) {
      if (parseInt(e.target.value) === 1) {
        if (!popOutWindow || popOutWindow.closed) {
          popOutWindow = window.open('', 'GameWindow', 'width=800,height=600');
          const popOutDoc = popOutWindow.document;
          
          // Create pop-out window content
          popOutDoc.write(`
            <!DOCTYPE html>
            <html>
            <head>
              <style>
                body { margin: 0; background: #222; overflow: hidden; }
                #popOutGrid { width: 100%; height: 100%; }
              </style>
            </head>
            <body>
              <div id="popOutGrid"></div>
            </body>
            </html>
          `);
          
          // Move grid to pop-out window
          const originalGrid = document.getElementById('grid');
          popOutDoc.getElementById('popOutGrid').appendChild(originalGrid);
          
          // Handle window resize
          popOutWindow.addEventListener('resize', function() {
            const size = Math.min(popOutWindow.innerWidth, popOutWindow.innerHeight) - 20;
            originalGrid.style.width = size + 'px';
            originalGrid.style.height = size + 'px';
          });
          
          // Handle window close
          popOutWindow.addEventListener('unload', function() {
            if (!popOutWindow.closed) {
              document.getElementById('mainContainer').insertBefore(originalGrid, document.getElementById('sidePanel'));
              originalGrid.style.width = '500px';
              originalGrid.style.height = '500px';
              document.getElementById('popOutMode').value = "0";
            }
          });
        }
      } else {
        if (popOutWindow && !popOutWindow.closed) {
          popOutWindow.close();
        }
      }
    });

    function moveBird(x, y, oldT) {
      if (moved[y][x]) return;
      
      birdTimers[y][x] += simulationTimeStep;
      
      // Change direction randomly
      if (birdTimers[y][x] >= 1.0) {
        if (Math.random() < 0.2) {
          birdDirections[y][x] *= -1;
        }
        if (Math.random() < 0.1) {
          birdYMovement[y][x] = Math.floor(Math.random() * 3) - 1; // -1, 0, or 1
        } else {
          birdYMovement[y][x] = 0;
        }
        birdTimers[y][x] = 0;
      }

      // Try to move in current direction
      let nx = x + birdDirections[y][x];
      let ny = y + birdYMovement[y][x];

      // Check boundaries and wrap around if needed
      if (nx < 0) nx = GRID_SIZE - 1;
      if (nx >= GRID_SIZE) nx = 0;
      if (ny < 0 || ny >= GRID_SIZE) {
        ny = y;
        birdYMovement[y][x] = 0;
      }

      // Check for oak leaves to eat
      let foundLeaves = false;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          let checkX = x + dx, checkY = y + dy;
          if (checkX >= 0 && checkX < GRID_SIZE && checkY >= 0 && checkY < GRID_SIZE) {
            if (grid[checkY][checkX] === OAK_LEAVES || grid[checkY][checkX] === OAK_BABY_LEAVES) {
              eraseCell(checkX, checkY);
              foundLeaves = true;
            }
          }
        }
      }

      // Move if possible
      if (grid[ny][nx] === EMPTY && !moved[ny][nx]) {
        moveCell(x, y, nx, ny, oldT, BIRD);
        birdDirections[ny][nx] = birdDirections[y][x];
        birdTimers[ny][nx] = birdTimers[y][x];
        birdYMovement[ny][nx] = birdYMovement[y][x];
      }
    }

    function moveOil(x, y, oldT) {
      if (moved[y][x]) return;
      
      if (y+1 < GRID_SIZE && grid[y+1][x] === EMPTY && !moved[y+1][x]) {
        moveCell(x, y, x, y+1, oldT, OIL);
      } else if (y+1 < GRID_SIZE && grid[y+1][x] === WATER && !moved[y+1][x]) {
        // Oil floats on water
        let tempWater = temp[y+1][x];
        grid[y+1][x] = OIL;
        temp[y+1][x] = oldT;
        grid[y][x] = WATER;
        temp[y][x] = tempWater;
        moved[y+1][x] = true;
      } else {
        let dirs = [];
        if (x > 0 && grid[y][x-1] === EMPTY && !moved[y][x-1]) dirs.push(-1);
        if (x < GRID_SIZE-1 && grid[y][x+1] === EMPTY && !moved[y][x+1]) dirs.push(1);
        shuffle(dirs);
        for (let dir of dirs) {
          let nx = x + dir;
          if (grid[y][nx] === EMPTY && !moved[y][nx]) {
            moveCell(x, y, nx, y, oldT, OIL);
            return;
          }
        }
      }
    }

    gridContainer.addEventListener('mousedown', onMouseDown);
    gridContainer.addEventListener('mouseup', onMouseUp);
    gridContainer.addEventListener('contextmenu', e => e.preventDefault());
    gridContainer.addEventListener('auxclick', e => {
      if (e.button === 1) { // Middle click
        e.preventDefault();
        const { x, y } = getMousePos(e);
        const element = grid[y][x];
        if (element === EMPTY) return;

        // Find the tool element for this element
        const tools = Array.from(toolElements);
        for (const tool of tools) {
          if (getToolElementId(tool.getAttribute('data-tool')) === element) {
            // Select the tool
            selectTool(tool);
            
            // Find its category
            const category = tool.getAttribute('data-cat');
            if (category) {
              // Select the category
              const categoryButtons = document.querySelectorAll('#categoryMenu button');
              categoryButtons.forEach(btn => {
                if (btn.getAttribute('data-category') === category) {
                  btn.click();
                  
                  // Wait for DOM update then scroll tool into view
                  setTimeout(() => {
                    tool.scrollIntoView({ behavior: 'smooth', block: 'center' });
                  }, 100);
                }
              });
            }
            break;
          }
        }
      }
    });

    // Helper function to get element ID from tool name
    function getToolElementId(toolName) {
      switch(toolName) {
        case "eraser": return ERASER;
        case "sand": return SAND;
        case "wall": return WALL;
        case "water": return WATER;
        case "lava": return LAVA;
        case "stone": return STONE;
        case "water-vapor": return WATER_VAPOR;
        case "copper": return COPPER;
        case "steel": return STEEL;
        case "ice": return ICE;
        case "wood": return WOOD;
        case "fire": return FIRE;
        case "smoke": return SMOKE;
        case "ash": return ASH;
        case "glass": return GLASS;
        case "bomb": return BOMB;
        case "dirt": return DIRT;
        case "wet-dirt": return WET_DIRT;
        case "wheat-seeds": return WHEAT_SEEDS;
        case "flour": return FLOUR;
        case "dough": return DOUGH;
        case "bread": return BREAD;
        case "plant-root": return ROOT;
        case "spark": return SPARK;
        case "oak-seeds": return OAK_SEEDS;
        case "grass": return GRASS;
        case "gas": return GAS;
        case "cooler": return COOLER;
        case "heater": return HEATER;
        case "heat-separator": return HEAT_SEPARATOR;
        case "input": return INPUT;
        case "output": return OUTPUT;
        case "not-gate": return NOT_GATE;
        case "and-gate": return AND_GATE;
        case "blocker": return BLOCKER;
        case "cloner": return CLONER;
        case "coal": return COAL;
        case "coal-lump": return COAL_LUMP;
        case "thermite": return THERMITE;
        case "acid": return ACID;
        case "slime": return SLIME;
        case "carbon-dioxide": return CARBON_DIOXIDE;
        case "oxygen": return OXYGEN;
        case "bird": return BIRD;
        case "meat": return MEAT;
        case "cooked-meat": return COOKED_MEAT;
        case "cobblestone": return COBBLESTONE;
        case "oil": return OIL;
        case "example-element": return EXAMPLE_ELEMENT;
        case "big-bomb": return BIG_BOMB;
        case "water-bomb": return WATER_BOMB;
        case "fire-bomb": return FIRE_BOMB;
        case "cryo-bomb": return CRYO_BOMB;
        case "nuke-bomb": return NUKE_BOMB;
        default: return null;
      }
    }

    // Add touch support
    let lastTouchX = null;
    let lastTouchY = null;
    let touchStartTime = 0;
    let isTouchActive = false;

    gridContainer.addEventListener('touchstart', function(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const { x, y } = getMousePos(touch);
      lastTouchX = x;
      lastTouchY = y;
      hoveredX = x;
      hoveredY = y;
      touchStartTime = Date.now();
      isTouchActive = true;
      isLeftMouseDown = true;
      spamPlace();
      updateHoverOverlay();
    });

    gridContainer.addEventListener('touchmove', function(e) {
      e.preventDefault();
      if (!isTouchActive) return;
      
      const touch = e.touches[0];
      const { x, y } = getMousePos(touch);
      
      // Only update if position changed
      if (x !== lastTouchX || y !== lastTouchY) {
        hoveredX = x;
        hoveredY = y;
        lastTouchX = x;
        lastTouchY = y;
        spamPlace();
        updateHoverOverlay();
        
        // Update HUD
        if (temp[y][x] !== null) {
          hudTemp.textContent = `Temp: ${temp[y][x].toFixed(1)} °C`;
          hudElem.textContent = `Element: ${getElementName(grid[y][x])}`;
        }
      }
    });

    gridContainer.addEventListener('touchend', function(e) {
      e.preventDefault();
      isLeftMouseDown = false;
      isTouchActive = false;
      hoveredX = null;
      hoveredY = null;
      lastTouchX = null;
      lastTouchY = null;
      hudTemp.textContent = "Temp: -- °C";
      hudElem.textContent = "Element: --";
      hudFPS.textContent = "FPS: --";
      hoverOverlay.style.display = "none";
    });

    gridContainer.addEventListener('touchcancel', function(e) {
      e.preventDefault();
      isLeftMouseDown = false;
      isTouchActive = false;
      hoveredX = null;
      hoveredY = null;
      lastTouchX = null;
      lastTouchY = null;
      hudTemp.textContent = "Temp: -- °C";
      hudElem.textContent = "Element: --";
      hudFPS.textContent = "FPS: --";
      hoverOverlay.style.display = "none";
    });

    // Update getMousePos to better handle touch events
    function getMousePos(e) {
      const cellSize = gridContainer.clientWidth / GRID_SIZE;
      let rect = gridContainer.getBoundingClientRect();
      let clientX = e.clientX || e.touches[0].clientX;
      let clientY = e.clientY || e.touches[0].clientY;
      let px = Math.floor((clientX - rect.left) / cellSize);
      let py = Math.floor((clientY - rect.top) / cellSize);
      return { 
        x: Math.max(0, Math.min(GRID_SIZE - 1, px)), 
        y: Math.max(0, Math.min(GRID_SIZE - 1, py)) 
      };
    }

    // Initialize dynamic lighting system
    window.isDynamicLightingEnabled = false;
    window.lightLevels = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    window.lightColors = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));

    // Add light-emitting properties for elements
    window.lightEmitters = {
      [LAVA]: { intensity: 1.0, color: '#ff4500' },
      [FIRE]: { intensity: 0.8, color: '#ffcc00' },
      [BURNING_WOOD]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_ORGANIC]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_LEAVES]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_ROOT]: { intensity: 0.6, color: '#ff4500' },
      [BURNING_COAL]: { intensity: 0.7, color: '#ff4500' },
      [BURNING_COAL_LUMP]: { intensity: 0.7, color: '#ff4500' },
      [BURNING_THERMITE]: { intensity: 1.0, color: '#ffc31f' },
      [BURNING_GAS]: { intensity: 0.5, color: '#ff6666' },
      [CHARGED_COPPER]: { intensity: 0.4, color: '#ff8c00' },
      [CHARGED_DOWN_COPPER]: { intensity: 0.3, color: '#cc6600' },
      [SPARK]: { intensity: 0.9, color: '#ffdd00' },
      [CHARGED_HEAT_SEPARATOR]: { intensity: 0.4, color: '#ffe033' },
      [CHARGED_DOWN_HEAT_SEPARATOR]: { intensity: 0.3, color: '#ffd700' },
      [CHARGED_INPUT]: { intensity: 0.4, color: '#ffff77' },
      [CHARGED_OUTPUT]: { intensity: 0.4, color: '#8888ff' },
      [MOLTEN_SLAG]: { intensity: 0.8, color: '#ff4500' }
    };

    // Add lighting calculation function
    function calculateLighting() {
      if (!window.isDynamicLightingEnabled) return;
      
      // Reset light levels
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          window.lightLevels[y][x] = 0;
          window.lightColors[y][x] = null;
        }
      }

      // Calculate light emission
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const element = grid[y][x];
          const emitter = window.lightEmitters[element];
          
          if (emitter) {
            // Spread light in a radius
            const radius = Math.floor(emitter.intensity * 5);
            for (let dy = -radius; dy <= radius; dy++) {
              for (let dx = -radius; dx <= radius; dx++) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  const distance = Math.sqrt(dx * dx + dy * dy);
                  if (distance <= radius) {
                    const intensity = (1 - distance / radius) * emitter.intensity;
                    window.lightLevels[ny][nx] = Math.max(window.lightLevels[ny][nx], intensity);
                    if (!window.lightColors[ny][nx]) window.lightColors[ny][nx] = emitter.color;
                    else {
                      // Mix colors based on intensity
                      const currentColor = window.lightColors[ny][nx];
                      const r1 = parseInt(currentColor.slice(1, 3), 16);
                      const g1 = parseInt(currentColor.slice(3, 5), 16);
                      const b1 = parseInt(currentColor.slice(5, 7), 16);
                      const r2 = parseInt(emitter.color.slice(1, 3), 16);
                      const g2 = parseInt(emitter.color.slice(3, 5), 16);
                      const b2 = parseInt(emitter.color.slice(5, 7), 16);
                      const mix = intensity / (window.lightLevels[ny][nx] + intensity);
                      const r = Math.round(r1 * (1 - mix) + r2 * mix);
                      const g = Math.round(g1 * (1 - mix) + g2 * mix);
                      const b = Math.round(b1 * (1 - mix) + b2 * mix);
                      window.lightColors[ny][nx] = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Modify renderCell to include lighting
    const originalRenderCell = window.renderCell;
    window.renderCell = function(x, y) {
      originalRenderCell(x, y);
      const cell = cells[y][x];
      
      if (window.isDynamicLightingEnabled && window.lightLevels[y][x] > 0) {
        cell.classList.add('lit');
        const element = grid[y][x];
        
        if (element === GLASS) {
          // Glass reflects nearby light with a slight tint
          const color = window.lightColors[y][x];
          const intensity = window.lightLevels[y][x];
          cell.style.backgroundColor = color;
          cell.style.opacity = intensity * 0.3;
        } else if (element === EMPTY) {
          // Empty cells show light more prominently
          const color = window.lightColors[y][x];
          cell.style.backgroundColor = color;
          cell.style.opacity = window.lightLevels[y][x] * 0.2;
        } else {
          // Other cells get a slight glow effect
          const lightColor = window.lightColors[y][x];
          if (lightColor) {
            cell.style.boxShadow = `0 0 ${window.lightLevels[y][x] * 10}px ${lightColor}`;
          }
        }
      } else {
        cell.classList.remove('lit');
        cell.style.boxShadow = '';
      }
    };

    // Add lighting calculation to game loop
    const originalGameLoop = window.gameLoop;
    window.gameLoop = function(timestamp) {
      if (window.isDynamicLightingEnabled) {
        calculateLighting();
      }
      originalGameLoop(timestamp);
    };

    // Initialize dynamic lighting toggle
    function initializeDynamicLighting() {
      const dynamicLightingSelect = document.getElementById('dynamicLighting');
      if (dynamicLightingSelect) {
        dynamicLightingSelect.addEventListener('change', function(e) {
          window.isDynamicLightingEnabled = parseInt(e.target.value) === 1;
          alert('Dynamic Lighting ' + (window.isDynamicLightingEnabled ? 'Enabled' : 'Disabled')); // Immediate feedback
          
          if (!window.isDynamicLightingEnabled) {
            // Clear all lighting effects
            for (let y = 0; y < GRID_SIZE; y++) {
              for (let x = 0; x < GRID_SIZE; x++) {
                const cell = cells[y][x];
                cell.classList.remove('lit');
                cell.style.boxShadow = '';
                if (grid[y][x] === EMPTY) {
                  cell.style.backgroundColor = '';
                  cell.style.opacity = '';
                }
              }
            }
          }
        });
      }
    }

    // Call initialization when document is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeDynamicLighting);
    } else {
      initializeDynamicLighting();
    }

    // Add to applyOptionsButton click handler
    document.getElementById('applyOptionsButton').addEventListener('click', function() {
      const newSize = parseInt(document.getElementById('stageSizeSelect').value);
      if (newSize !== GRID_SIZE) {
        initGrid(newSize);
        // Only reinitialize lighting arrays if size changed
        window.lightLevels = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
        window.lightColors = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
      }
      optionsModal.style.display = 'none';
    });
  </script>

  <!-- Mod Manager Modal -->
  <div id="modMenu" class="modal">
    <div class="modal-content">
      <span id="closeModMenu" class="close">&times;</span>
      <h2>Mod Manager</h2>
      <div id="modListContainer">
        <!-- Mod cards will be dynamically inserted here -->
      </div>
      <button id="addModButton">+ Add New Mod</button>
    </div>
  </div>

  <!-- Add New Mod Modal (only mod code textarea, forced mod info comes from code) -->
  <div id="addModModal" class="modal">
    <div class="modal-content">
      <span id="closeAddModModal" class="close">&times;</span>
      <h2>Add New Mod</h2>
      <textarea id="newModCode" rows="10" placeholder="Paste your mod JS code here"></textarea>
      <button id="saveNewModButton">Save Mod</button>
    </div>
  </div>

  <!-- Options Modal -->
  <div id="optionsModal" class="modal">
    <div class="modal-content">
      <span id="closeOptionsModal" class="close">&times;</span>
      <h2>Options</h2>
      <div class="options-content">
        <div class="options-section">
          <h3>Game Options</h3>
          <div class="option-item">
            <label for="stageSizeSelect">Stage Size (Requires Canvas Clear):</label>
            <select id="stageSizeSelect">
              <option value="25">25x25x25</option>
              <option value="50" selected>50x50x50</option>
              <option value="75">75x75x75</option>
              <option value="100">100x100x100</option>
              <option value="125">125x125x125</option>
            </select>
            <p class="option-description">Larger sizes provide more space and detail, but will require more processing power.</p> <br> <p class="option-description" style="color:red;">WARNING: Changing the stage size will completely clear the current canvas. This action cannot be undone.</p>
          </div>

          <div class="option-item">
            <button id="generateTerrainBtn" class="options-button" onclick="generateTerrain()">Generate Terrain</button>
            <p class="option-description">Creates a procedurally generated world with caves, ores, and surface features.</p>
          </div>

          <div class="option-item">
            <button id="downloadOfflineBtn" class="options-button">Download Offline Version</button>
            <p class="option-description">Downloads a standalone version of the game that can be played without internet connection.</p>
          </div>
        </div>

        <div class="options-section disabled">
          <h3>Graphics Settings (Dev Build Only)</h3>
          <div class="option-item">
            <label for="variatedColors">Variated Colors:</label>
            <select id="variatedColors">
              <option value="off" selected>Off</option>
              <option value="fast">Fast</option>
              <option value="fancy">Fancy</option>
            </select>
            <p class="option-description">Adds slight color variations to elements for a more natural look. Fast mode uses simple variations, while Fancy adds dynamic shading.</p>
          </div>
        </div>

        <div class="options-section experimental">
          <h3>Experimental Features</h3>
          <div class="option-item">
            <label for="popOutMode">[UNSTABLE] Pop-Out Mode:</label>
            <select id="popOutMode">
              <option value="0">Off</option>
              <option value="1">On</option>
            </select>
            <p class="option-description">Opens the simulation in a separate window that can be resized independently. Currently unstable and WILL cause issues.</p>
          </div>
          <div class="option-item">
            <label for="setting-dabyfps">DabyFPS:</label>
            <select id="setting-dabyfps">
              <option value="false" selected>OFF</option>
              <option value="true">ON</option>
            </select>
            <p class="option-description">Runs the game at the same frame rate regardless of FPS. Even with immense lag, the game will still run at the simulation speed without slowing down.</p>
          </div>
          <div class="option-item" id="fps-cap-container" style="display:none;">
            <label for="setting-fps-cap">FPS Cap:</label>
            <select id="setting-fps-cap">
              <option value="30">30</option>
              <option value="60" selected>60</option>
              <option value="75">75</option>
              <option value="100">100</option>
              <option value="120">120</option>
              <option value="165">165</option>
              <option value="175">175</option>
              <option value="200">200</option>
              <option value="230">230</option>
              <option value="365">365</option>
              <option value="512">512</option>
            </select>
            <p class="option-description">Sets the FPS for the game (the speed at which the game should run at) and ensures the FPS never goes above.</p>
          </div>
        </div>
      </div>
      <button id="applyOptionsButton" style="display: none !important">Apply Required Clear Settings (WILL CLEAR CANVAS)</button>
    </div>
  </div>

  <!-- Save/Load Modal -->
  <div id="saveLoadModal" class="modal">
    <div class="modal-content">
      <span id="closeSaveLoadModal" class="close">&times;</span>
      <h2>Save / Load</h2>
      <div>
        <h3>Save Current Game</h3>
        <input type="text" id="saveTitle" placeholder="Save Title">
        <input type="text" id="saveDescription" placeholder="Save Description">
        <button id="saveGameButton">Save Game</button>
      </div>
      <hr>
      <div>
        <h3>Saved Games</h3>
        <div id="savedGamesList">
          <!-- List of saved games will appear here -->
        </div>
      </div>
      <hr>
      <div>
        <h3>Import Save File (.dbr)</h3>
        <input type="file" id="importFileInput" accept=".dbr">
        <button id="importSaveButton">Import Save</button>
      </div>
    </div>
  </div>

  <script>
    // Global mods list
    const modsList = [];
    // Function to parse forcedModInfo from mod code using regex
    function parseForcedModInfo(modCode) {
      const regex = /window\.forcedModInfo\s*=\s*(\{[\s\S]*?\});/m;
      const match = modCode.match(regex);
      if (match && match[1]) {
        try {
          return (new Function("return " + match[1]))();
        } catch (e) {
          console.error("Error parsing forcedModInfo:", e);
          return null;
        }
      }
      return null;
    }
    // Add the default mod (Orange Juice mod) to the modsList.
    const orangeJuiceModCode = `(function(){
      // ----------------------------------------------------------------------
      // FORCE MOD IDENTIFICATION
      // ----------------------------------------------------------------------
      window.forcedModInfo = {
        id: 'exampleElementMod',
        title: 'Example Element Mod',
        description: 'Adds a simple example element that deletes anything it touches. Great for learning how to make mods!',
        gameVersion: '0.7.1c'
      };

      // ----------------------------------------------------------------------
      // DEFINE THE NEW ELEMENT CONSTANT
      // ----------------------------------------------------------------------
      if (typeof window.EXAMPLE_ELEMENT === 'undefined') {
        window.EXAMPLE_ELEMENT = 67;
      }

      // ----------------------------------------------------------------------
      // INJECT CSS TO STYLE THE MOD'S TOOL AND CELLS
      // ----------------------------------------------------------------------
      var style = document.createElement('style');
      style.innerHTML = \`
        .tool.example-element { 
          background: linear-gradient(45deg, #ff00ff, #00ffff) !important;
          border: 2px solid white !important;
        }
        .example-element { 
          background: linear-gradient(45deg, #ff00ff, #00ffff) !important;
          border: 2px solid white !important;
        }
      \`;
      document.head.appendChild(style);

      // ----------------------------------------------------------------------
      // SAVE ORIGINAL FUNCTIONS FOR TERMINATION
      // ----------------------------------------------------------------------
      if (!window.exampleElementModOriginals) {
        window.exampleElementModOriginals = {
          selectTool: selectTool,
          placeElementAt: placeElementAt,
          getElementName: getElementName,
          renderCell: renderCell,
          performSimulationStep: performSimulationStep
        };
      }

      // ----------------------------------------------------------------------
      // CREATE THE MOD TOOL BUTTON
      // ----------------------------------------------------------------------
      var exampleTool = document.createElement('div');
      exampleTool.className = 'tool example-element';
      exampleTool.setAttribute('data-tool', 'example-element');
      exampleTool.setAttribute('data-cat', 'special');
      exampleTool.title = 'Example Element';
      var span = document.createElement('span');
      span.textContent = 'EX';
      exampleTool.appendChild(span);
      toolbar.appendChild(exampleTool);
      exampleTool.addEventListener('click', function(){
        selectTool(exampleTool);
      });

      // ----------------------------------------------------------------------
      // PATCH THE selectTool FUNCTION
      // ----------------------------------------------------------------------
      selectTool = function(el) {
        var toolName = el.getAttribute('data-tool');
        if (toolName === 'example-element') {
          currentTool = EXAMPLE_ELEMENT;
          Array.from(toolElements).forEach(function(t){ t.classList.remove('selected'); });
          el.classList.add('selected');
        } else {
          window.exampleElementModOriginals.selectTool(el);
        }
      };

      // ----------------------------------------------------------------------
      // PATCH THE placeElementAt FUNCTION
      // ----------------------------------------------------------------------
      placeElementAt = function(x, y, tool) {
        if (tool === EXAMPLE_ELEMENT) {
          eraseCell(x, y);
          grid[y][x] = EXAMPLE_ELEMENT;
          temp[y][x] = 20;
        } else {
          window.exampleElementModOriginals.placeElementAt(x, y, tool);
        }
      };

      // ----------------------------------------------------------------------
      // PATCH getElementName TO SHOW EXAMPLE ELEMENT
      // ----------------------------------------------------------------------
      getElementName = function(e) {
        if (e === EXAMPLE_ELEMENT) return "Example Element";
        return window.exampleElementModOriginals.getElementName(e);
      };

      // ----------------------------------------------------------------------
      // PATCH renderCell TO RENDER EXAMPLE ELEMENT CELLS
      // ----------------------------------------------------------------------
      renderCell = function(x, y) {
        const cell = cells[y][x];
        cell.className = 'cell';
        cell.style.opacity = "";
        cell.style.backgroundColor = "";
        var e = grid[y][x];
        if (e === EXAMPLE_ELEMENT) {
          cell.classList.add('example-element');
        } else {
          window.exampleElementModOriginals.renderCell(x, y);
        }
      };

      // ----------------------------------------------------------------------
      // PATCH performSimulationStep TO PROCESS EXAMPLE ELEMENT CELLS
      // ----------------------------------------------------------------------
      var origPerformSimStep = window.exampleElementModOriginals.performSimulationStep;
      performSimulationStep = function() {
        // Process Example Element behavior
        for (let y = 0; y < GRID_SIZE; y++) {
          for (let x = 0; x < GRID_SIZE; x++) {
            if (grid[y][x] === EXAMPLE_ELEMENT && !moved[y][x]) {
              // Delete adjacent cells
              let neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
              for (let [dx, dy] of neighbors) {
                let nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  if (grid[ny][nx] !== EMPTY && grid[ny][nx] !== EXAMPLE_ELEMENT) {
                    eraseCell(nx, ny);
                  }
                }
              }
              
              // Move randomly
              let possibleMoves = [];
              for (let [dx, dy] of neighbors) {
                let nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  if (grid[ny][nx] === EMPTY) {
                    possibleMoves.push([nx, ny]);
                  }
                }
              }
              
              if (possibleMoves.length > 0) {
                let [nx, ny] = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                moveCell(x, y, nx, ny, temp[y][x], EXAMPLE_ELEMENT);
              }
            }
          }
        }
        origPerformSimStep();
      };
    })();`;

    const orangeJuiceTerminateCode = `(function(){
      if(window.exampleElementModOriginals) {
        selectTool = window.exampleElementModOriginals.selectTool;
        placeElementAt = window.exampleElementModOriginals.placeElementAt;
        getElementName = window.exampleElementModOriginals.getElementName;
        renderCell = window.exampleElementModOriginals.renderCell;
        performSimulationStep = window.exampleElementModOriginals.performSimulationStep;
      }
    })();`;

    modsList.push({
      id: 'exampleElementMod',
      title: 'Example Element Mod',
      description: 'Adds a simple example element that deletes anything it touches. Great for learning how to make mods!',
      gameVersion: '0.5.0a',
      code: orangeJuiceModCode,
      terminateCode: orangeJuiceTerminateCode,
      enabled: false
    });
    function isModCompatible(mod) {
      // Only allow mods from exact version match
      return mod.gameVersion === currentGameVersion;
    }
    function updateModListUI() {
      const container = document.getElementById('modListContainer');
      container.innerHTML = '';
      modsList.forEach(mod => {
        const card = document.createElement('div');
        card.className = 'modCard';
        const titleEl = document.createElement('h3');
        titleEl.textContent = mod.title;
        const descEl = document.createElement('p');
        descEl.textContent = mod.description;
        const versionEl = document.createElement('small');
        versionEl.textContent = "Version: " + mod.gameVersion;
        if (!isModCompatible(mod)) {
          versionEl.classList.add('incompatible');
          versionEl.title = "Incompatible! Made for version " + mod.gameVersion;
        }
        const statusEl = document.createElement('div');
        statusEl.textContent = 'Status: ' + (mod.enabled ? 'Enabled' : 'Disabled');
        const execButton = document.createElement('button');
        execButton.textContent = 'Execute Code';
        execButton.addEventListener('click', () => {
          if (!mod.enabled) {
            try {
              eval(mod.code);
              mod.enabled = true;
              updateModListUI();
            } catch (e) {
              statusEl.textContent = 'Error: ' + e;
            }
          }
        });
        const termButton = document.createElement('button');
        termButton.textContent = 'Terminate';
        termButton.addEventListener('click', () => {
          if (mod.enabled && mod.terminateCode) {
            try {
              eval(mod.terminateCode);
              mod.enabled = false;
              updateModListUI();
            } catch (e) {
              statusEl.textContent = 'Error: ' + e;
            }
          }
        });
        card.appendChild(titleEl);
        card.appendChild(descEl);
        card.appendChild(versionEl);
        card.appendChild(statusEl);
        card.appendChild(execButton);
        card.appendChild(termButton);
        container.appendChild(card);
      });
    }
    const modButton = document.getElementById('modButton');
    const modMenu = document.getElementById('modMenu');
    const closeModMenu = document.getElementById('closeModMenu');
    modButton.addEventListener('click', function() {
      modMenu.style.display = 'block';
      updateModListUI();
    });
    closeModMenu.addEventListener('click', function() {
      modMenu.style.display = 'none';
    });
    window.addEventListener('click', function(event) {
      if (event.target == modMenu) {
        modMenu.style.display = 'none';
      }
    });
    const addModButton = document.getElementById('addModButton');
    const addModModal = document.getElementById('addModModal');
    const closeAddModModal = document.getElementById('closeAddModModal');
    const saveNewModButton = document.getElementById('saveNewModButton');
    addModButton.addEventListener('click', function() {
      addModModal.style.display = 'block';
    });
    closeAddModModal.addEventListener('click', function() {
      addModModal.style.display = 'none';
    });
    window.addEventListener('click', function(event) {
      if (event.target == addModModal) {
        addModModal.style.display = 'none';
      }
    });
    saveNewModButton.addEventListener('click', function() {
      const modCode = document.getElementById('newModCode').value;
      if (modCode.trim() !== '') {
        const forcedInfo = parseForcedModInfo(modCode);
        if (forcedInfo && forcedInfo.id && forcedInfo.title && forcedInfo.description && forcedInfo.gameVersion) {
          const newMod = {
            id: forcedInfo.id,
            title: forcedInfo.title,
            description: forcedInfo.description,
            gameVersion: forcedInfo.gameVersion,
            code: modCode,
            terminateCode: '',
            enabled: false
          };
          modsList.push(newMod);
          updateModListUI();
          document.getElementById('newModCode').value = '';
          addModModal.style.display = 'none';
        }
      }
    });
    const optionsButton = document.getElementById('optionsButton');
    const optionsModal = document.getElementById('optionsModal');
    const closeOptionsModal = document.getElementById('closeOptionsModal');
    optionsButton.addEventListener('click', function() {
      optionsModal.style.display = 'block';
      // Initialize dynamic lighting select with current state
      const dynamicLightingSelect = document.getElementById('dynamicLighting');
      if (dynamicLightingSelect) {
        dynamicLightingSelect.value = window.isDynamicLightingEnabled ? '1' : '0';
      }
    });
    closeOptionsModal.addEventListener('click', function() {
      optionsModal.style.display = 'none';
    });
    window.addEventListener('click', function(event) {
      if (event.target == optionsModal) {
        optionsModal.style.display = 'none';
      }
    });
    document.getElementById('applyOptionsButton').addEventListener('click', function() {
      const size = parseInt(document.getElementById('stageSizeSelect').value);
      initGrid(size);
      optionsModal.style.display = 'none';
    });
    const saveLoadButton = document.getElementById('saveLoadButton');
    const saveLoadModal = document.getElementById('saveLoadModal');
    const closeSaveLoadModal = document.getElementById('closeSaveLoadModal');
    saveLoadButton.addEventListener('click', function() {
      saveLoadModal.style.display = 'block';
      updateSavedGamesList();
    });
    closeSaveLoadModal.addEventListener('click', function() {
      saveLoadModal.style.display = 'none';
    });
    window.addEventListener('click', function(event) {
      if (event.target == saveLoadModal) {
        saveLoadModal.style.display = 'none';
      }
    });
    function getSaveIndex() {
      const index = localStorage.getItem("dbr_save_index");
      return index ? JSON.parse(index) : [];
    }
    function setSaveIndex(index) {
      localStorage.setItem("dbr_save_index", JSON.stringify(index));
    }
    function saveGame() {
      const title = document.getElementById('saveTitle').value.trim();
      const description = document.getElementById('saveDescription').value.trim();
      if (!title) return;
      const saveData = {
        GRID_SIZE,
        grid, temp, vaporLife, cloudLife, fireLife, smokeLife, burningWoodTime, wheatHeight, wheatMaxHeight,
        seedGrowthTime, rootLife, sparkLife, sparkTimer, smokeMaxLife, cloudMaxLife, branchLevel,
        branchLen, branchMaxArr, branchSubCount, branchDirX, branchDirY, oakTreeGrowthTime, oakTreeHeight,
        oakTreeMaxHeight, oakTreeRootTimer, oakTreeRootDepth, oakTreeRootMax, grassStage, burningGasTime,
        chargedStateTime
      };
      const key = "dbr_save_" + Date.now();
      localStorage.setItem(key, JSON.stringify(saveData));
      let index = getSaveIndex();
      index.push({ key, title, description, timestamp: Date.now() });
      setSaveIndex(index);
      updateSavedGamesList();
      document.getElementById('saveTitle').value = '';
      document.getElementById('saveDescription').value = '';
    }
    document.getElementById('saveGameButton').addEventListener('click', saveGame);
    function updateSavedGamesList() {
      const container = document.getElementById('savedGamesList');
      container.innerHTML = "";
      const index = getSaveIndex();
      index.forEach(item => {
        const div = document.createElement('div');
        div.style.border = "1px solid #888";
        div.style.padding = "5px";
        div.style.margin = "5px 0";
        div.innerHTML = "<strong>" + item.title + "</strong><br>" + item.description;
        const loadBtn = document.createElement('button');
        loadBtn.textContent = "Load";
        loadBtn.addEventListener('click', () => {
          const data = localStorage.getItem(item.key);
          if (data) {
            const save = JSON.parse(data);
            GRID_SIZE = save.GRID_SIZE;
            initGrid(GRID_SIZE); // Create the grid DOM elements first.
            // Then restore the saved state into your global variables:
            grid = save.grid;
            temp = save.temp;
            vaporLife = save.vaporLife;
            cloudLife = save.cloudLife;
            fireLife = save.fireLife;
            smokeLife = save.smokeLife;
            burningWoodTime = save.burningWoodTime;
            wheatHeight = save.wheatHeight;
            wheatMaxHeight = save.wheatMaxHeight;
            seedGrowthTime = save.seedGrowthTime;
            rootLife = save.rootLife;
            sparkLife = save.sparkLife;
            sparkTimer = save.sparkTimer;
            smokeMaxLife = save.smokeMaxLife;
            cloudMaxLife = save.cloudMaxLife;
            branchLevel = save.branchLevel;
            branchLen = save.branchLen;
            branchMaxArr = save.branchMaxArr;
            branchSubCount = save.branchSubCount;
            branchDirX = save.branchDirX;
            branchDirY = save.branchDirY;
            oakTreeGrowthTime = save.oakTreeGrowthTime;
            oakTreeHeight = save.oakTreeHeight;
            oakTreeMaxHeight = save.oakTreeMaxHeight;
            oakTreeRootTimer = save.oakTreeRootTimer;
            oakTreeRootDepth = save.oakTreeRootDepth;
            oakTreeRootMax = save.oakTreeRootMax;
            grassStage = save.grassStage;
            burningGasTime = save.burningGasTime;
            chargedStateTime = save.chargedStateTime;
            renderGrid(); // Update the canvas with the loaded state.
          }
        });
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = "Delete";
        deleteBtn.addEventListener('click', () => {
          let index = getSaveIndex();
          index = index.filter(i => i.key !== item.key);
          setSaveIndex(index);
          localStorage.removeItem(item.key);
          updateSavedGamesList();
        });
        const exportBtn = document.createElement('button');
        exportBtn.textContent = "Export";
        exportBtn.addEventListener('click', () => {
          const data = localStorage.getItem(item.key);
          if (data) {
            const blob = new Blob([data], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = item.title + ".dbr";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          }
        });
        div.appendChild(loadBtn);
        div.appendChild(deleteBtn);
        div.appendChild(exportBtn);
        container.appendChild(div);
      });
    }
    document.getElementById('importSaveButton').addEventListener('click', () => {
      const fileInput = document.getElementById('importFileInput');
      const file = fileInput.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const save = JSON.parse(e.target.result);
          const key = "dbr_save_" + Date.now();
          localStorage.setItem(key, JSON.stringify(save));
          let index = getSaveIndex();
          index.push({ key, title: file.name, description: "Imported Save", timestamp: Date.now() });
          setSaveIndex(index);
          updateSavedGamesList();
        } catch (err) {
          console.error("Import error", err);
        }
      };
      reader.readAsText(file);
    });

    document.getElementById('stageSizeSelect').addEventListener('change', function() {
      const newSize = parseInt(this.value);
      if (newSize !== GRID_SIZE) {
        pendingStageSize = newSize;
        confirmationModal.style.display = 'block';
      } else {
        pendingStageSize = null;
        confirmationModal.style.display = 'none';
        document.getElementById('applyOptionsButton').style.display = 'none';
      }
    });

    confirmYes.addEventListener('click', function() {
      if (pendingStageSize !== null) {
        initGrid(pendingStageSize);
        pendingStageSize = null;
        confirmationModal.style.display = 'none';
        optionsModal.style.display = 'none';
      }
    });

    confirmNo.addEventListener('click', function() {
      pendingStageSize = null;
      confirmationModal.style.display = 'none';
      document.getElementById('stageSizeSelect').value = GRID_SIZE.toString();
      document.getElementById('applyOptionsButton').style.display = 'none';
    });

    // DabyFPS setting
    document.getElementById('setting-dabyfps').value = localStorage.getItem('setting-dabyfps') || 'false';
    document.getElementById('setting-dabyfps').addEventListener('change', function() {
      localStorage.setItem('setting-dabyfps', this.value);
      // Show or hide the FPS cap setting based on DabyFPS being enabled
      document.getElementById('fps-cap-container').style.display = 
        this.value === 'true' ? 'block' : 'none';
    });
    
    // FPS Cap setting
    document.getElementById('setting-fps-cap').value = localStorage.getItem('setting-fps-cap') || '60';
    document.getElementById('setting-fps-cap').addEventListener('change', function() {
      localStorage.setItem('setting-fps-cap', this.value);
    });
    
    // Show/hide FPS cap based on saved DabyFPS setting
    document.getElementById('fps-cap-container').style.display = 
      document.getElementById('setting-dabyfps').value === 'true' ? 'block' : 'none';
  </script>

  <!-- Initialize all event handlers after DOM is loaded -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Debug elements
      const debugTab = document.querySelector('button[data-category="debug"]');
      if (debugTab) debugTab.style.display = 'none';
      
      const debugElements = document.querySelectorAll('.tool[data-cat*="debug"]');
      debugElements.forEach(elem => {
        elem.style.display = 'none';
      });


      // DabyFPS handler
      const dabyFpsSelect = document.getElementById('dabyFps');
      if (dabyFpsSelect) {
        dabyFpsSelect.addEventListener('change', function(e) {
          targetFps = parseInt(e.target.value);
        });
      }

      // Pop out mode handler
      const popOutModeSelect = document.getElementById('popOutMode');
      if (popOutModeSelect) {
        popOutModeSelect.addEventListener('change', function(e) {
          if (parseInt(e.target.value) === 1) {
            if (!popOutWindow || popOutWindow.closed) {
              popOutWindow = window.open('', 'GameWindow', 'width=800,height=600');
              const popOutDoc = popOutWindow.document;
              
              // Create pop-out window content
              popOutDoc.write(`
                <!DOCTYPE html>
                <html>
                <head>
                  <style>
                    body { margin: 0; background: #222; overflow: hidden; }
                    #popOutGrid { width: 100%; height: 100%; }
                  </style>
                </head>
                <body>
                  <div id="popOutGrid"></div>
                </body>
                </html>
              `);
              
              // Move grid to pop-out window
              const originalGrid = document.getElementById('grid');
              popOutDoc.getElementById('popOutGrid').appendChild(originalGrid);
              
              // Handle window resize
              popOutWindow.addEventListener('resize', function() {
                const size = Math.min(popOutWindow.innerWidth, popOutWindow.innerHeight) - 20;
                originalGrid.style.width = size + 'px';
                originalGrid.style.height = size + 'px';
              });
              
              // Handle window close
              popOutWindow.addEventListener('unload', function() {
                if (!popOutWindow.closed) {
                  document.getElementById('mainContainer').insertBefore(originalGrid, document.getElementById('sidePanel'));
                  originalGrid.style.width = '500px';
                  originalGrid.style.height = '500px';
                  document.getElementById('popOutMode').value = "0";
                }
              });
            }
          } else {
            if (popOutWindow && !popOutWindow.closed) {
              popOutWindow.close();
            }
          }
        });
      }

      // Store the current stage size
      let currentStageSize = GRID_SIZE;
      const stageSizeSelect = document.getElementById('stageSizeSelect');
      const applyButton = document.getElementById('applyOptionsButton');

      // Update stage size select to show current size
      stageSizeSelect.value = currentStageSize.toString();

      // Handle stage size change
      stageSizeSelect.addEventListener('change', function(e) {
        const newSize = parseInt(e.target.value);
        if (newSize !== currentStageSize) {
          applyButton.style.display = 'block';
          applyButton.classList.add('show-clear-warning');
        } else {
          applyButton.style.display = 'none';
          applyButton.classList.remove('show-clear-warning');
        }
      });

      // Modify applyOptionsButton click handler
      applyButton.addEventListener('click', function() {
        const newSize = parseInt(stageSizeSelect.value);
        if (newSize !== currentStageSize) {
          currentStageSize = newSize;
          initGrid(newSize);
          applyButton.style.display = 'none';
          applyButton.classList.remove('show-clear-warning');
        }
        optionsModal.style.display = 'none';
      });

      // When options modal is opened, check if size is different
      document.getElementById('optionsButton').addEventListener('click', function() {
        const newSize = parseInt(stageSizeSelect.value);
        if (newSize !== currentStageSize) {
          applyButton.style.display = 'block';
          applyButton.classList.add('show-clear-warning');
        } else {
          applyButton.style.display = 'none';
          applyButton.classList.remove('show-clear-warning');
        }
        optionsModal.style.display = 'block';
      });
    });

    // Start the game loop
    requestAnimationFrame(gameLoop);
  </script>

  <script>
    // Terrain Generation - moved to global scope
    window.generateTerrain = function() {
      // Clear the grid first
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          eraseCell(x, y);
        }
      }

      // Generate surface level (about 30% down from top)
      const surfaceLevel = Math.floor(GRID_SIZE * 0.3);
      
      // Generate perlin noise for surface variation
      const surfaceNoise = [];
      for (let x = 0; x < GRID_SIZE; x++) {
        surfaceNoise[x] = Math.sin(x * 0.1) * 3 + Math.random() * 2;
      }

      // Generate caves using a simple cellular automata approach
      let caves = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(false));
      
      // Initialize random cave seeds (increased frequency)
      for (let y = surfaceLevel + 5; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (Math.random() < 0.2) { // Increased from 0.1 to 0.2
            caves[y][x] = true;
          }
        }
      }

      // Smooth caves
      for (let i = 0; i < 3; i++) {
        const newCaves = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(false));
        for (let y = 0; y < GRID_SIZE; y++) {
          for (let x = 0; x < GRID_SIZE; x++) {
            let neighbors = 0;
            for (let dy = -1; dy <= 1; dy++) {
              for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue;
                const nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  if (caves[ny][nx]) neighbors++;
                }
              }
            }
            newCaves[y][x] = neighbors >= 4 || (caves[y][x] && neighbors >= 3);
          }
        }
        caves = newCaves;
      }

      // Generate terrain
      for (let x = 0; x < GRID_SIZE; x++) {
        const localSurface = Math.floor(surfaceLevel + surfaceNoise[x]);
        
        // Generate seeds and plants first
        if (Math.random() < 0.15) {
          grid[localSurface][x] = OAK_SEEDS;
          temp[localSurface][x] = 20;
        } else if (Math.random() < 0.15) {
          grid[localSurface][x] = WHEAT_SEEDS;
          temp[localSurface][x] = 20;
        }
        
        // Generate grass layer
        grid[localSurface + 1][x] = GRASS;
        temp[localSurface + 1][x] = 20;
        
        // Add atmospheric gasses
        if (Math.random() < 0.1 && localSurface > 0) {
          grid[localSurface - 1][x] = Math.random() < 0.5 ? CARBON_DIOXIDE : OXYGEN;
          temp[localSurface - 1][x] = 20;
        }
        
        // Generate dirt and occasional cobblestone layer
        for (let y = localSurface + 2; y < localSurface + 7; y++) {
          if (y >= GRID_SIZE) continue;
          if (!caves[y][x]) {
            if (Math.random() < 0.1) {
              grid[y][x] = COBBLESTONE;
            } else {
              grid[y][x] = DIRT;
            }
            temp[y][x] = 20;
          }
        }
        
        // Generate stone layer with ores
        for (let y = localSurface + 7; y < GRID_SIZE; y++) {
          if (!caves[y][x]) {
            if (Math.random() < 0.05) { // Ore generation
              const depth = y / GRID_SIZE; // 0 to 1, deeper = higher
              if (depth > 0.8 && Math.random() < 0.3) { // Deep ores
                grid[y][x] = STEEL;
              } else if (depth > 0.6 && Math.random() < 0.3) { // Mid-deep ores
                grid[y][x] = COPPER;
              } else if (Math.random() < 0.4) { // Common ore
                grid[y][x] = COAL;
              } else {
                grid[y][x] = STONE;
              }
            } else {
              grid[y][x] = STONE;
            }
            temp[y][x] = 20;
          }
        }
      }

      // Add water/lava to caves
      for (let y = surfaceLevel + 5; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (caves[y][x] && Math.random() < 0.02) { // Increased from 0.01 to 0.02
            const isLava = y > GRID_SIZE * 0.7 && Math.random() < 0.3;
            let fillQueue = [[x, y]];
            let filled = new Set();
            let fillCount = 0;
            const maxFill = 50;

            while (fillQueue.length > 0 && fillCount < maxFill) {
              const [cx, cy] = fillQueue.shift();
              const key = `${cx},${cy}`;
              if (filled.has(key)) continue;
              
              if (caves[cy][cx] && grid[cy][cx] === EMPTY) {
                grid[cy][cx] = isLava ? LAVA : WATER;
                temp[cy][cx] = isLava ? 1200 : 20;
                filled.add(key);
                fillCount++;

                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx,dy]) => {
                  const nx = cx + dx, ny = cy + dy;
                  if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    fillQueue.push([nx, ny]);
                  }
                });
              }
            }
          }
        }
      }

      // Add oil deposits near bottom
      for (let y = Math.floor(GRID_SIZE * 0.8); y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (caves[y][x] && Math.random() < 0.03) {
            let fillQueue = [[x, y]];
            let filled = new Set();
            let fillCount = 0;
            const maxFill = 30; // Smaller oil deposits

            while (fillQueue.length > 0 && fillCount < maxFill) {
              const [cx, cy] = fillQueue.shift();
              const key = `${cx},${cy}`;
              if (filled.has(key)) continue;
              
              if (caves[cy][cx] && grid[cy][cx] === EMPTY) {
                grid[cy][cx] = OIL;
                temp[cy][cx] = 20;
                filled.add(key);
                fillCount++;

                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx,dy]) => {
                  const nx = cx + dx, ny = cy + dy;
                  if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    fillQueue.push([nx, ny]);
                  }
                });
              }
            }
          }
        }
      }

      // Add random birds near surface
      for (let y = 0; y < surfaceLevel; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === EMPTY && Math.random() < 0.01) {
            grid[y][x] = BIRD;
            temp[y][x] = 20;
          }
        }
      }
    };
  </script>
</body>
</html>
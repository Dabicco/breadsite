<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mod List</title>
  <style>
    /* Global styles */
    body {
      background: #f0f0f0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      color: #333;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
    }
    #searchBar {
      display: block;
      margin: 0 auto 20px;
      width: 80%;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 5px;
    }
    #modContainer {
      max-width: 900px;
      margin: 0 auto;
    }
    .mod-card {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    .mod-card h2 {
      margin-top: 0;
      color: #222;
    }
    .mod-card p {
      font-size: 14px;
      line-height: 1.5;
    }
    .mod-card small {
      color: #888;
      font-size: 12px;
    }
    .mod-code {
      background: #272822;
      color: #f8f8f2;
      padding: 10px;
      border-radius: 5px;
      overflow: auto;
      white-space: pre-wrap;
      font-family: 'Courier New', Courier, monospace;
      max-height: 300px;
      margin-top: 10px;
      border: 1px solid #333;
    }
    .copy-button {
      background: #007BFF;
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 10px;
      font-size: 14px;
    }
    .copy-button:hover {
      background: #0056b3;
    }
    /* Fancy scrollbar styling for code blocks */
    .mod-code::-webkit-scrollbar {
      width: 10px;
    }
    .mod-code::-webkit-scrollbar-track {
      background: #444;
      border-radius: 5px;
    }
    .mod-code::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 5px;
    }
    .mod-code::-webkit-scrollbar-thumb:hover {
      background: #aaa;
    }
  </style>
</head>
<body>
  <h1>Mod List</h1>
  <input type="text" id="searchBar" placeholder="Search mods...">
  <div id="modContainer"></div>
  <script>
    // Array of mod objects
    const mods = [
      {
        id: 'magneticFieldMod',
        title: 'Magnetic Field Mod',
        description: 'Adds a new Magnet element that generates a magnetic field which gradually attracts metallic elements (copper, charged copper, steel) toward it.',
        gameVersion: '0.4.9a',
        code: `(function(){
  // ----------------------------------------------------------------------
  // FORCE MOD IDENTIFICATION
  // ----------------------------------------------------------------------
  window.forcedModInfo = {
    id: 'magneticFieldMod',
    title: 'Magnetic Field Mod',
    description: 'Adds a new Magnet element that generates a magnetic field which gradually attracts metallic elements (copper, charged copper, steel) toward it.',
    gameVersion: '0.4.9a'
  };

  // ----------------------------------------------------------------------
  // DEFINE THE NEW ELEMENT CONSTANT
  // ----------------------------------------------------------------------
  if (typeof window.MAGNET === 'undefined') {
    window.MAGNET = 68; // New element id for Magnet
  }

  // ----------------------------------------------------------------------
  // INJECT CSS TO STYLE THE MOD'S TOOL AND CELLS
  // ----------------------------------------------------------------------
  var style = document.createElement('style');
  style.innerHTML = \`
    .tool.magnet { background-color: #8a2be2 !important; }
    .magnet { background-color: #8a2be2 !important; }
  \`;
  document.head.appendChild(style);

  // ----------------------------------------------------------------------
  // SAVE ORIGINAL FUNCTIONS FOR TERMINATION
  // ----------------------------------------------------------------------
  if (!window.magneticFieldModOriginals) {
    window.magneticFieldModOriginals = {
      selectTool: selectTool,
      placeElementAt: placeElementAt,
      performSimulationStep: performSimulationStep,
      getElementName: getElementName,
      renderCell: renderCell
    };
  }

  // ----------------------------------------------------------------------
  // CREATE THE MOD TOOL BUTTON
  // ----------------------------------------------------------------------
  var magnetTool = document.createElement('div');
  magnetTool.className = 'tool magnet';
  magnetTool.setAttribute('data-tool', 'magnet');
  magnetTool.setAttribute('data-cat', 'special');
  magnetTool.title = 'Magnet';
  var span = document.createElement('span');
  span.textContent = 'Mag';
  magnetTool.appendChild(span);
  toolbar.appendChild(magnetTool);
  magnetTool.addEventListener('click', function(){
    selectTool(magnetTool);
  });

  // ----------------------------------------------------------------------
  // PATCH THE selectTool FUNCTION
  // ----------------------------------------------------------------------
  selectTool = function(el) {
    var toolName = el.getAttribute('data-tool');
    if (toolName === 'magnet') {
      currentTool = MAGNET;
      Array.from(toolElements).forEach(function(t){ t.classList.remove('selected'); });
      el.classList.add('selected');
    } else {
      window.magneticFieldModOriginals.selectTool(el);
    }
  };

  // ----------------------------------------------------------------------
  // PATCH THE placeElementAt FUNCTION
  // ----------------------------------------------------------------------
  placeElementAt = function(x, y, tool) {
    if (tool === MAGNET) {
      eraseCell(x, y);
      grid[y][x] = MAGNET;
      temp[y][x] = 20; // initial temperature
    } else {
      window.magneticFieldModOriginals.placeElementAt(x, y, tool);
    }
  };

  // ----------------------------------------------------------------------
  // PATCH getElementName TO SHOW "Magnet [Modded]"
  // ----------------------------------------------------------------------
  getElementName = function(e) {
    if (e === MAGNET) return "Magnet [Modded]";
    return window.magneticFieldModOriginals.getElementName(e);
  };

  // ----------------------------------------------------------------------
  // PATCH THE renderCell FUNCTION TO RENDER MAGNET CELLS
  // ----------------------------------------------------------------------
  renderCell = function(x, y) {
    const cell = cells[y][x];
    cell.className = 'cell';
    cell.style.opacity = "";
    cell.style.backgroundColor = "";
    var e = grid[y][x];
    if (e === MAGNET) {
      cell.classList.add('magnet');
      cell.style.backgroundColor = "#8a2be2";
    } else {
      window.magneticFieldModOriginals.renderCell(x, y);
    }
  };

  // ----------------------------------------------------------------------
  // PATCH THE performSimulationStep FUNCTION TO HANDLE MAGNET
  // ----------------------------------------------------------------------
  var originalPerformSimStep = window.magneticFieldModOriginals.performSimulationStep;
  performSimulationStep = function() {
    // Process Magnet behavior before normal simulation step.
    for (let y = 0; y < GRID_SIZE; y++){
      for (let x = 0; x < GRID_SIZE; x++){
        if (!moved[y][x] && grid[y][x] === MAGNET) {
          // Define a longer radius for the magnetic field
          var magneticRadius = 10;
          // Scan all cells in a square around the magnet
          for (let dy = -magneticRadius; dy <= magneticRadius; dy++){
            for (let dx = -magneticRadius; dx <= magneticRadius; dx++){
              let nx = x + dx, ny = y + dy;
              if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                // Check for metallic elements (copper, charged copper, or steel)
                if (grid[ny][nx] === COPPER || grid[ny][nx] === CHARGED_COPPER || grid[ny][nx] === STEEL) {
                  // Calculate the Euclidean distance
                  let dist = Math.sqrt(dx * dx + dy * dy);
                  // Only attempt to move if the element is not already adjacent and with a chance for gradual movement
                  if (dist > 1 && Math.random() < 0.3) {
                    // Compute a step of 1 cell toward the magnet
                    let stepX = dx > 0 ? -1 : (dx < 0 ? 1 : 0);
                    let stepY = dy > 0 ? -1 : (dy < 0 ? 1 : 0);
                    let targetX = nx + stepX, targetY = ny + stepY;
                    if (targetX >= 0 && targetX < GRID_SIZE && targetY >= 0 && targetY < GRID_SIZE && grid[targetY][targetX] === EMPTY) {
                      moveCell(nx, ny, targetX, targetY, temp[ny][nx], grid[ny][nx]);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    originalPerformSimStep();
  };
})();`
      },
      {
        id: 'instantLightningStrikeMod',
        title: 'Instant Lightning Strike Mod',
        description: 'Adds a lightning strike element that instantly calculates a downward path—with random lateral shifts—leaving behind a visible trail for 0.7s, then explodes after 1s.',
        gameVersion: '0.4.9a',
        code: `(function(){
  // ----------------------------------------------------------------------
  // FORCE MOD IDENTIFICATION
  // ----------------------------------------------------------------------
  window.forcedModInfo = {
    id: 'instantLightningStrikeMod',
    title: 'Instant Lightning Strike Mod',
    description: 'Adds a lightning strike element that instantly calculates a downward path—with random lateral shifts—leaving behind a visible trail for 0.7s, then explodes after 1s.',
    gameVersion: '0.4.9a'
  };

  // ----------------------------------------------------------------------
  // DEFINE NEW ELEMENT CONSTANTS
  // ----------------------------------------------------------------------
  if (typeof window.LIGHTNING_STRIKE === 'undefined') {
    window.LIGHTNING_STRIKE = 69;
  }
  if (typeof window.LIGHTNING_TRAIL === 'undefined') {
    window.LIGHTNING_TRAIL = 70;
  }

  // ----------------------------------------------------------------------
  // INJECT CSS TO STYLE THE MOD'S TOOL, STRIKE, AND TRAIL CELLS
  // ----------------------------------------------------------------------
  var style = document.createElement('style');
  style.innerHTML = \`
    .tool.lightning { background-color: gold !important; }
    .lightning { background-color: gold !important; }
    .lightning-trail { background-color: #ffd700 !important; } /* pale gold */
  \`;
  document.head.appendChild(style);

  // ----------------------------------------------------------------------
  // SAVE ORIGINAL FUNCTIONS FOR TERMINATION
  // ----------------------------------------------------------------------
  if (!window.instantLightningStrikeModOriginals) {
    window.instantLightningStrikeModOriginals = {
      selectTool: selectTool,
      placeElementAt: placeElementAt,
      performSimulationStep: performSimulationStep,
      getElementName: getElementName,
      renderCell: renderCell
    };
  }

  // ----------------------------------------------------------------------
  // CREATE THE MOD TOOL BUTTON
  // ----------------------------------------------------------------------
  var lightningTool = document.createElement('div');
  lightningTool.className = 'tool lightning';
  lightningTool.setAttribute('data-tool', 'lightning');
  lightningTool.setAttribute('data-cat', 'special');
  lightningTool.title = 'Lightning Strike';
  var span = document.createElement('span');
  span.textContent = 'Lgt';
  lightningTool.appendChild(span);
  toolbar.appendChild(lightningTool);
  lightningTool.addEventListener('click', function(){
    selectTool(lightningTool);
  });

  // ----------------------------------------------------------------------
  // PATCH THE selectTool FUNCTION
  // ----------------------------------------------------------------------
  selectTool = function(el) {
    var toolName = el.getAttribute('data-tool');
    if (toolName === 'lightning') {
      currentTool = LIGHTNING_STRIKE;
      Array.from(toolElements).forEach(function(t){ t.classList.remove('selected'); });
      el.classList.add('selected');
    } else {
      window.instantLightningStrikeModOriginals.selectTool(el);
    }
  };

  // ----------------------------------------------------------------------
  // SET UP MOD-SPECIFIC ARRAYS FOR TIMERS
  // ----------------------------------------------------------------------
  if (typeof window.lightningTimers === 'undefined') {
    window.lightningTimers = [];
    for (let y = 0; y < GRID_SIZE; y++) {
      lightningTimers[y] = [];
      for (let x = 0; x < GRID_SIZE; x++) {
        lightningTimers[y][x] = null;
      }
    }
  }
  if (typeof window.lightningTrailTimers === 'undefined') {
    window.lightningTrailTimers = [];
    for (let y = 0; y < GRID_SIZE; y++) {
      lightningTrailTimers[y] = [];
      for (let x = 0; x < GRID_SIZE; x++) {
        lightningTrailTimers[y][x] = null;
      }
    }
  }

  // ----------------------------------------------------------------------
  // PATCH THE placeElementAt FUNCTION
  // ----------------------------------------------------------------------
  // When placing a lightning strike, instantly compute its downward path with random lateral shifts.
  placeElementAt = function(x, y, tool) {
    if (tool === LIGHTNING_STRIKE) {
      // Compute the entire path instantly.
      let currentX = x, currentY = y;
      let path = [];
      path.push({ x: currentX, y: currentY });
      // Continue downward until reaching bottom or encountering a non-empty cell.
      while (currentY < GRID_SIZE - 1 && grid[currentY+1][currentX] === EMPTY) {
        // With a 30% chance, try a lateral shift.
        if (Math.random() < 0.3) {
          let lateralDir = Math.random() < 0.5 ? -1 : 1;
          let newX = currentX + lateralDir;
          // Check lateral bounds and ensure both the lateral cell at the same row and below it are empty.
          if (newX >= 0 && newX < GRID_SIZE && grid[currentY][newX] === EMPTY && grid[currentY+1][newX] === EMPTY) {
            currentX = newX;
          }
        }
        currentY++;
        path.push({ x: currentX, y: currentY });
      }
      // For every cell in the path except the last one, mark it as a lightning trail.
      for (let i = 0; i < path.length - 1; i++) {
        let pos = path[i];
        grid[pos.y][pos.x] = LIGHTNING_TRAIL;
        temp[pos.y][pos.x] = 20;
        lightningTrailTimers[pos.y][pos.x] = 0; // initialize trail timer
      }
      // The bottom cell becomes the active lightning strike.
      let bottom = path[path.length - 1];
      grid[bottom.y][bottom.x] = LIGHTNING_STRIKE;
      temp[bottom.y][bottom.x] = 20;
      lightningTimers[bottom.y][bottom.x] = 0; // initialize explosion timer
      return;
    } else {
      window.instantLightningStrikeModOriginals.placeElementAt(x, y, tool);
    }
  };

  // ----------------------------------------------------------------------
  // PATCH getElementName TO SHOW "Lightning Strike [Modded]"
  // ----------------------------------------------------------------------
  getElementName = function(e) {
    if (e === LIGHTNING_STRIKE) return "Lightning Strike [Modded]";
    return window.instantLightningStrikeModOriginals.getElementName(e);
  };

  // ----------------------------------------------------------------------
  // PATCH renderCell TO RENDER LIGHTNING STRIKE AND TRAIL CELLS
  // ----------------------------------------------------------------------
  renderCell = function(x, y) {
    const cell = cells[y][x];
    cell.className = 'cell';
    cell.style.opacity = "";
    cell.style.backgroundColor = "";
    var e = grid[y][x];
    if (e === LIGHTNING_STRIKE) {
      cell.classList.add('lightning');
      cell.style.backgroundColor = "gold";
    } else if (e === LIGHTNING_TRAIL) {
      cell.classList.add('lightning-trail');
      cell.style.backgroundColor = "#ffd700";
    } else {
      window.instantLightningStrikeModOriginals.renderCell(x, y);
    }
  };

  // ----------------------------------------------------------------------
  // PATCH performSimulationStep TO HANDLE LIGHTNING STRIKE EXPLOSION AND TRAIL DECAY
  // ----------------------------------------------------------------------
  var origPerformSimStep = window.instantLightningStrikeModOriginals.performSimulationStep;
  performSimulationStep = function() {
    // Process lightning trail decay: any trail cell older than 0.7 seconds vanishes.
    for (let y = 0; y < GRID_SIZE; y++) {
      for (let x = 0; x < GRID_SIZE; x++) {
        if (grid[y][x] === LIGHTNING_TRAIL) {
          if (lightningTrailTimers[y][x] === null) {
            lightningTrailTimers[y][x] = 0;
          } else {
            lightningTrailTimers[y][x] += simulationTimeStep;
            if (lightningTrailTimers[y][x] >= 0.7) {
              eraseCell(x, y);
              lightningTrailTimers[y][x] = null;
            }
          }
        }
      }
    }
    // Process explosion for lightning strike cells.
    for (let y = 0; y < GRID_SIZE; y++){
      for (let x = 0; x < GRID_SIZE; x++){
        if (!moved[y][x] && grid[y][x] === LIGHTNING_STRIKE) {
          if (lightningTimers[y][x] === null) {
            lightningTimers[y][x] = 0;
          }
          lightningTimers[y][x] += simulationTimeStep;
          // After 1 second, trigger an explosion and clear the column (both strike and trail).
          if (lightningTimers[y][x] >= 1.0) {
            explodeBomb(x, y);
            for (let clearY = y; clearY >= 0; clearY--) {
              if (grid[clearY][x] === LIGHTNING_STRIKE || grid[clearY][x] === LIGHTNING_TRAIL) {
                eraseCell(x, clearY);
                lightningTimers[clearY][x] = null;
                lightningTrailTimers[clearY][x] = null;
              } else {
                break;
              }
            }
          }
        }
      }
    }
    origPerformSimStep();
  };
})();`
      },
      {
        id: 'portalMod',
        title: 'Portal Mod',
        description: 'Adds two paired portal elements (Portal A and Portal B) that work in both directions. When an element touches either portal, it is teleported to a random empty neighbor around the partner portal. Teleported elements receive a cooldown so they aren’t reabsorbed immediately.',
        gameVersion: '0.4.9a',
        code: `(function(){
  // ----------------------------------------------------------------------
  // FORCE MOD IDENTIFICATION
  // ----------------------------------------------------------------------
  window.forcedModInfo = {
    id: 'portalMod',
    title: 'Portal Mod',
    description: 'Adds two paired portal elements (Portal A and Portal B) that work in both directions. When an element touches either portal, it is teleported to a random empty neighbor around the partner portal. Teleported elements receive a cooldown so they aren’t reabsorbed immediately.',
    gameVersion: '0.4.9a'
  };

  // ----------------------------------------------------------------------
  // DEFINE NEW ELEMENT CONSTANTS
  // ----------------------------------------------------------------------
  if (typeof window.PORTAL_A === 'undefined') {
    window.PORTAL_A = 71;
  }
  if (typeof window.PORTAL_B === 'undefined') {
    window.PORTAL_B = 72;
  }

  // ----------------------------------------------------------------------
  // INJECT CSS TO STYLE THE MOD'S TOOLS AND CELLS
  // ----------------------------------------------------------------------
  var style = document.createElement('style');
  style.innerHTML = \`
    .tool.portal-a { background-color: deepskyblue !important; }
    .tool.portal-b { background-color: orchid !important; }
    .portal-a { background-color: deepskyblue !important; }
    .portal-b { background-color: orchid !important; }
  \`;
  document.head.appendChild(style);

  // ----------------------------------------------------------------------
  // SAVE ORIGINAL FUNCTIONS FOR TERMINATION
  // ----------------------------------------------------------------------
  if (!window.portalModOriginals) {
    window.portalModOriginals = {
      selectTool: selectTool,
      placeElementAt: placeElementAt,
      performSimulationStep: performSimulationStep,
      getElementName: getElementName,
      renderCell: renderCell
    };
  }

  // ----------------------------------------------------------------------
  // GLOBAL VARIABLES FOR PORTAL PAIR LOCATIONS & TELEPORT COOLDOWN
  // ----------------------------------------------------------------------
  // These store the coordinates of the most recently placed portals.
  window.portalAPos = null;
  window.portalBPos = null;
  // Create a 2D array to track teleport cooldowns so teleported elements are not reabsorbed immediately.
  if (typeof window.portalCooldown === 'undefined') {
    window.portalCooldown = [];
    for (let y = 0; y < GRID_SIZE; y++) {
      portalCooldown[y] = [];
      for (let x = 0; x < GRID_SIZE; x++) {
        portalCooldown[y][x] = 0;
      }
    }
  }

  // ----------------------------------------------------------------------
  // CREATE THE MOD TOOL BUTTONS
  // ----------------------------------------------------------------------
  // Create Portal A button.
  var portalATool = document.createElement('div');
  portalATool.className = 'tool portal-a';
  portalATool.setAttribute('data-tool', 'portal-a');
  portalATool.setAttribute('data-cat', 'special');
  portalATool.title = 'Portal A';
  var spanA = document.createElement('span');
  spanA.textContent = 'PA';
  portalATool.appendChild(spanA);
  toolbar.appendChild(portalATool);
  portalATool.addEventListener('click', function(){
    selectTool(portalATool);
  });
  // Create Portal B button.
  var portalBTool = document.createElement('div');
  portalBTool.className = 'tool portal-b';
  portalBTool.setAttribute('data-tool', 'portal-b');
  portalBTool.setAttribute('data-cat', 'special');
  portalBTool.title = 'Portal B';
  var spanB = document.createElement('span');
  spanB.textContent = 'PB';
  portalBTool.appendChild(spanB);
  toolbar.appendChild(portalBTool);
  portalBTool.addEventListener('click', function(){
    selectTool(portalBTool);
  });

  // ----------------------------------------------------------------------
  // PATCH THE selectTool FUNCTION
  // ----------------------------------------------------------------------
  selectTool = function(el) {
    var toolName = el.getAttribute('data-tool');
    if (toolName === 'portal-a') {
      currentTool = PORTAL_A;
      Array.from(toolElements).forEach(function(t){ t.classList.remove('selected'); });
      el.classList.add('selected');
    } else if (toolName === 'portal-b') {
      currentTool = PORTAL_B;
      Array.from(toolElements).forEach(function(t){ t.classList.remove('selected'); });
      el.classList.add('selected');
    } else {
      window.portalModOriginals.selectTool(el);
    }
  };

  // ----------------------------------------------------------------------
  // PATCH THE placeElementAt FUNCTION
  // ----------------------------------------------------------------------
  // When placing a portal element, record its coordinates.
  placeElementAt = function(x, y, tool) {
    if (tool === PORTAL_A) {
      eraseCell(x, y);
      grid[y][x] = PORTAL_A;
      temp[y][x] = 20;
      window.portalAPos = { x: x, y: y };
      return;
    } else if (tool === PORTAL_B) {
      eraseCell(x, y);
      grid[y][x] = PORTAL_B;
      temp[y][x] = 20;
      window.portalBPos = { x: x, y: y };
      return;
    } else {
      window.portalModOriginals.placeElementAt(x, y, tool);
    }
  };

  // ----------------------------------------------------------------------
  // PATCH getElementName TO SHOW "Portal A [Modded]" OR "Portal B [Modded]"
  // ----------------------------------------------------------------------
  getElementName = function(e) {
    if (e === PORTAL_A) return "Portal A [Modded]";
    if (e === PORTAL_B) return "Portal B [Modded]";
    return window.portalModOriginals.getElementName(e);
  };

  // ----------------------------------------------------------------------
  // PATCH renderCell TO RENDER PORTAL CELLS
  // ----------------------------------------------------------------------
  renderCell = function(x, y) {
    const cell = cells[y][x];
    cell.className = 'cell';
    cell.style.opacity = "";
    cell.style.backgroundColor = "";
    var e = grid[y][x];
    if (e === PORTAL_A) {
      cell.classList.add('portal-a');
      cell.style.backgroundColor = "deepskyblue";
    } else if (e === PORTAL_B) {
      cell.classList.add('portal-b');
      cell.style.backgroundColor = "orchid";
    } else {
      window.portalModOriginals.renderCell(x, y);
    }
  };

  // ----------------------------------------------------------------------
  // UTILITY: Get empty neighbors around a given position
  // ----------------------------------------------------------------------
  function getEmptyNeighbors(pos) {
    let neighbors = [];
    for (let dy = -1; dy <= 1; dy++){
      for (let dx = -1; dx <= 1; dx++){
        if (dx === 0 && dy === 0) continue;
        let nx = pos.x + dx, ny = pos.y + dy;
        if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && grid[ny][nx] === EMPTY) {
          neighbors.push({ x: nx, y: ny });
        }
      }
    }
    return neighbors;
  }

  // ----------------------------------------------------------------------
  // PATCH performSimulationStep TO PROCESS PORTAL TELEPORTATION WITH COOLDOWN
  // ----------------------------------------------------------------------
  var origPerformSimStep = window.portalModOriginals.performSimulationStep;
  performSimulationStep = function() {
    // Update portal cooldowns for all cells.
    for (let y = 0; y < GRID_SIZE; y++) {
      for (let x = 0; x < GRID_SIZE; x++) {
        if (portalCooldown[y][x] > 0) {
          portalCooldown[y][x] -= simulationTimeStep;
          if (portalCooldown[y][x] < 0) portalCooldown[y][x] = 0;
        }
      }
    }
    // Process portal teleportation for both portals.
    for (let y = 0; y < GRID_SIZE; y++){
      for (let x = 0; x < GRID_SIZE; x++){
        if ((grid[y][x] === PORTAL_A || grid[y][x] === PORTAL_B)) {
          // Determine partner portal position.
          let partnerPos = null;
          if (grid[y][x] === PORTAL_A && window.portalBPos) {
            partnerPos = window.portalBPos;
          } else if (grid[y][x] === PORTAL_B && window.portalAPos) {
            partnerPos = window.portalAPos;
          }
          if (partnerPos) {
            let adjacent = [];
            for (let dy = -1; dy <= 1; dy++){
              for (let dx = -1; dx <= 1; dx++){
                if (dx === 0 && dy === 0) continue;
                let nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                  // Only consider non-empty, non-portal cells that are not on cooldown.
                  if (grid[ny][nx] !== EMPTY && grid[ny][nx] !== PORTAL_A && grid[ny][nx] !== PORTAL_B && portalCooldown[ny][nx] === 0) {
                    adjacent.push({ x: nx, y: ny });
                  }
                }
              }
            }
            if (adjacent.length > 0) {
              adjacent.forEach(function(pos) {
                let targetCandidates = getEmptyNeighbors(partnerPos);
                if (targetCandidates.length > 0) {
                  let target = targetCandidates[Math.floor(Math.random() * targetCandidates.length)];
                  moveCell(pos.x, pos.y, target.x, target.y, temp[pos.y][pos.x], grid[pos.y][pos.x]);
                  // Set a cooldown for the teleported cell to prevent immediate reabsorption.
                  portalCooldown[target.y][target.x] = 1.0;
                }
              });
            }
          }
        }
      }
    }
    origPerformSimStep();
  };
})();`
      },
      {
        id: 'dabyFPSMod',
        title: 'DabyFPS Mod',
        description: 'Caps the game FPS at 60 and, if FPS falls below 60, internally speeds up simulation steps (based on a base speed of ~0.3) to keep the game in time without changing the speed slider.',
        gameVersion: '0.4.9a',
        code: `(function(){
  // ----------------------------------------------------------------------
  // FORCE MOD IDENTIFICATION
  // ----------------------------------------------------------------------
  window.forcedModInfo = {
    id: 'dabyFPSMod',
    title: 'DabyFPS Mod',
    description: 'Caps the game FPS at 60 and, if FPS falls below 60, internally speeds up simulation steps (based on a base speed of ~0.3) to keep the game in time without changing the speed slider.',
    gameVersion: '0.4.9a'
  };

  // ----------------------------------------------------------------------
  // SAVE ORIGINAL FUNCTIONS FOR TERMINATION
  // ----------------------------------------------------------------------
  if (!window.dabyFPSModOriginals) {
    window.dabyFPSModOriginals = {
      requestAnimationFrame: window.requestAnimationFrame,
      gameLoop: gameLoop
    };
  }

  // ----------------------------------------------------------------------
  // OVERRIDE requestAnimationFrame TO CAP FPS AT 60
  // ----------------------------------------------------------------------
  window.requestAnimationFrame = function(callback) {
    return window.setTimeout(callback, 1000/60);
  };

  // ----------------------------------------------------------------------
  // PATCH THE gameLoop FUNCTION TO COMPENSATE FOR LOW FPS
  // ----------------------------------------------------------------------
  var originalGameLoop = window.dabyFPSModOriginals.gameLoop;
  gameLoop = function() {
    frames++;
    const now = performance.now();
    if(now - lastTime >= 1000){
      fps = frames;
      frames = 0;
      lastTime = now;
    }
    hudFPS.textContent = \`FPS: \${fps}\`;
    spamPlace();
    let effectiveSpeed = speed;
    if(fps > 0 && fps < 60){
      effectiveSpeed = speed * (60 / fps);
    }
    stepAccumulator += effectiveSpeed;
    while(stepAccumulator >= 1){
      resetMoved();
      performSimulationStep();
      updateTemperature();
      unifyCopperClusters();
      processTransformations();
      stepAccumulator -= 1;
    }
    updateHUD();
    renderGrid();
    requestAnimationFrame(gameLoop);
  };
})();`
      },
      {
        id: 'debugMod',
        title: 'Daby Debug Mod',
        description: 'Press "s" to toggle a draggable, resizable debug console overlay that displays all console.log messages. It auto-scrolls to the bottom unless you scroll up; a "Scroll Down" button restores auto scroll.',
        gameVersion: '0.4.9a',
        code: `(function(){
  // ----------------------------------------------------------------------
  // FORCE MOD IDENTIFICATION
  // ----------------------------------------------------------------------
  window.forcedModInfo = {
    id: 'debugMod',
    title: 'Daby Debug Mod',
    description: 'Press "s" to toggle a draggable, resizable debug console overlay that displays all console.log messages. It auto-scrolls to the bottom unless you scroll up; a "Scroll Down" button restores auto scroll.',
    gameVersion: '0.4.9a'
  };

  // ----------------------------------------------------------------------
  // SAVE ORIGINAL FUNCTIONS FOR TERMINATION
  // ----------------------------------------------------------------------
  if (!window.debugModOriginals) {
    window.debugModOriginals = {
      consoleLog: console.log,
      addKeyListener: window.addEventListener
    };
  }

  // ----------------------------------------------------------------------
  // GLOBAL DEBUG MESSAGE STORAGE & AUTO-SCROLL FLAG
  // ----------------------------------------------------------------------
  window.debugMessages = [];
  window.autoScrollEnabled = true;

  // Override console.log to capture messages.
  console.log = function(...args) {
    window.debugModOriginals.consoleLog.apply(console, args);
    let message = args.map(arg => {
      if (typeof arg === "object") {
        try {
          return JSON.stringify(arg);
        } catch(e) {
          return String(arg);
        }
      }
      return String(arg);
    }).join(" ");
    let timestamp = new Date().toLocaleTimeString();
    let fullMessage = \`[\${timestamp}] \${message}\`;
    window.debugMessages.push(fullMessage);
    if (window.debugConsoleDiv && window.debugConsoleDiv.style.display === "block") {
      updateDebugConsole();
    }
  };

  function createDebugConsole(){
    if(window.debugConsoleDiv) return;

    let div = document.createElement("div");
    div.id = "debugConsole";
    div.style.position = "fixed";
    div.style.top = "10px";
    div.style.left = "10px";
    div.style.width = "80%";
    div.style.height = "300px";
    div.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    div.style.color = "#0f0";
    div.style.fontFamily = "monospace";
    div.style.fontSize = "12px";
    div.style.overflow = "hidden";
    div.style.zIndex = "2000";
    div.style.border = "1px solid #444";

    let header = document.createElement("div");
    header.id = "debugConsoleHeader";
    header.style.backgroundColor = "#222";
    header.style.cursor = "move";
    header.style.padding = "5px";
    header.style.fontWeight = "bold";
    header.textContent = "Debug Console";
    
    let autoScrollBtn = document.createElement("button");
    autoScrollBtn.textContent = "Scroll Down";
    autoScrollBtn.style.float = "right";
    autoScrollBtn.style.marginLeft = "5px";
    autoScrollBtn.style.backgroundColor = "#444";
    autoScrollBtn.style.color = "#fff";
    autoScrollBtn.style.border = "none";
    autoScrollBtn.style.cursor = "pointer";
    autoScrollBtn.addEventListener("click", function(){
      window.autoScrollEnabled = true;
      scrollToBottom();
    });
    header.appendChild(autoScrollBtn);
    
    let closeBtn = document.createElement("button");
    closeBtn.textContent = "X";
    closeBtn.style.float = "right";
    closeBtn.style.backgroundColor = "#444";
    closeBtn.style.color = "#fff";
    closeBtn.style.border = "none";
    closeBtn.style.cursor = "pointer";
    closeBtn.addEventListener("click", function(){
      div.style.display = "none";
    });
    header.appendChild(closeBtn);
    div.appendChild(header);

    let messagesDiv = document.createElement("div");
    messagesDiv.id = "debugMessagesContainer";
    messagesDiv.style.marginTop = "40px";
    messagesDiv.style.padding = "5px";
    messagesDiv.style.overflowY = "auto";
    messagesDiv.style.height = "calc(100% - 40px)";
    div.appendChild(messagesDiv);

    let resizer = document.createElement("div");
    resizer.id = "debugConsoleResizer";
    resizer.style.width = "15px";
    resizer.style.height = "15px";
    resizer.style.background = "#444";
    resizer.style.position = "absolute";
    resizer.style.right = "0";
    resizer.style.bottom = "0";
    resizer.style.cursor = "se-resize";
    div.appendChild(resizer);

    document.body.appendChild(div);
    window.debugConsoleDiv = div;

    header.onmousedown = dragMouseDown;
    function dragMouseDown(e) {
      e = e || window.event;
      e.preventDefault();
      let pos3 = e.clientX, pos4 = e.clientY;
      document.onmouseup = closeDragElement;
      document.onmousemove = elementDrag;
      function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        let pos1 = pos3 - e.clientX;
        let pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        div.style.top = (div.offsetTop - pos2) + "px";
        div.style.left = (div.offsetLeft - pos1) + "px";
      }
      function closeDragElement() {
        document.onmouseup = null;
        document.onmousemove = null;
      }
    }

    resizer.onmousedown = resizeMouseDown;
    function resizeMouseDown(e) {
      e = e || window.event;
      e.preventDefault();
      document.onmouseup = stopResizing;
      document.onmousemove = resizeElement;
      function resizeElement(e) {
        e = e || window.event;
        e.preventDefault();
        div.style.width = (e.clientX - div.offsetLeft) + "px";
        div.style.height = (e.clientY - div.offsetTop) + "px";
      }
      function stopResizing() {
        document.onmouseup = null;
        document.onmousemove = null;
      }
    }

    messagesDiv.addEventListener("scroll", function(){
      let threshold = 20;
      if (messagesDiv.scrollTop + messagesDiv.clientHeight >= messagesDiv.scrollHeight - threshold) {
        window.autoScrollEnabled = true;
      } else {
        window.autoScrollEnabled = false;
      }
    });
  }

  function scrollToBottom(){
    if(window.debugConsoleDiv){
      let messagesDiv = window.debugConsoleDiv.querySelector("#debugMessagesContainer");
      if(messagesDiv){
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
      }
    }
  }

  function updateDebugConsole(){
    if(!window.debugConsoleDiv) return;
    let messagesDiv = window.debugConsoleDiv.querySelector("#debugMessagesContainer");
    if(messagesDiv){
      messagesDiv.innerHTML = window.debugMessages.join("<br>");
      if(window.autoScrollEnabled){
        scrollToBottom();
      }
    }
  }

  function debugToggleConsole(e){
    if(e.key === "s" && !["INPUT", "TEXTAREA"].includes(e.target.tagName)){
      if(!window.debugConsoleDiv){
        createDebugConsole();
        window.debugConsoleDiv.style.display = "block";
        updateDebugConsole();
      } else {
        if(window.debugConsoleDiv.style.display === "none" || window.debugConsoleDiv.style.display === ""){
          window.debugConsoleDiv.style.display = "block";
          updateDebugConsole();
        } else {
          window.debugConsoleDiv.style.display = "none";
        }
      }
    }
  }
  window.debugToggleConsole = debugToggleConsole;
  window.addEventListener("keydown", debugToggleConsole);
})();`
      },
      {
        id: 'everythingLoggerMod',
        title: 'Everything Logger Mod',
        description: 'Logs key events in the game (element placements, cell erasures, movements, mod loading, menu interactions, and key events) to the console. Simulation steps are not logged to reduce clutter.',
        gameVersion: '0.4.9a',
        code: `(function(){
  // ----------------------------------------------------------------------
  // FORCE MOD IDENTIFICATION
  // ----------------------------------------------------------------------
  window.forcedModInfo = {
    id: 'everythingLoggerMod',
    title: 'Everything Logger Mod',
    description: 'Logs key events in the game (element placements, cell erasures, movements, mod loading, menu interactions, and key events) to the console. Simulation steps are not logged to reduce clutter.',
    gameVersion: '0.4.9a'
  };

  // ----------------------------------------------------------------------
  // SAVE ORIGINAL FUNCTIONS FOR TERMINATION
  // ----------------------------------------------------------------------
  var originalPlaceElementAt = placeElementAt;
  var originalEraseCell = eraseCell;
  var originalMoveCell = moveCell;
  
  // ----------------------------------------------------------------------
  // OVERRIDE CORE FUNCTIONS WITH LOGGING (EXCEPT SIMULATION STEPS)
  // ----------------------------------------------------------------------
  placeElementAt = function(x, y, tool) {
    console.log("[Everything Logger] placeElementAt called at (" + x + ", " + y + ") with tool:", tool);
    return originalPlaceElementAt(x, y, tool);
  };

  eraseCell = function(x, y) {
    console.log("[Everything Logger] eraseCell called at (" + x + ", " + y + ")");
    return originalEraseCell(x, y);
  };

  moveCell = function(x, y, nx, ny, oldT, newElem) {
    console.log("[Everything Logger] moveCell from (" + x + ", " + y + ") to (" + nx + ", " + ny + ") - oldTemp: " + oldT + ", newElem:", newElem);
    return originalMoveCell(x, y, nx, ny, oldT, newElem);
  };

  console.log("[Everything Logger] Everything Logger Mod loaded.");

  var modMenu = document.getElementById('modMenu');
  if(modMenu){
    modMenu.addEventListener('click', function(e){
      console.log("[Everything Logger] Mod menu clicked:", e);
    });
  }
  
  var sidePanel = document.getElementById('sidePanel');
  if(sidePanel){
    sidePanel.addEventListener('click', function(e){
      console.log("[Everything Logger] Side panel clicked:", e);
    });
  }

  function logKeyDown(e){
    console.log("[Everything Logger] KeyDown: " + e.key, e);
  }
  window.addEventListener("keydown", logKeyDown);
  window.everythingLoggerKeyListener = logKeyDown;
})();`
      },
      {
        id: 'gameOfLifeMod',
        title: 'Game Of Life Mod',
        description: 'Adds a suite of Game Of Life variants as new elements under a dedicated "Game Of Life Mod" category. Includes Conway’s, StructuredX (B278/S3456/6), Walled Cities (B45678/S2345), Seeds (B2/S), Gnarl (B1/S1), Diamoeba (B35678/S5678), Stains (B3678/S235678), Long Life (B345/S5), Maze (B3/S12345), Coagulations (B378/S235678), 3-4 (B34/S34), Living On The Edge (B37/S3458/4), Assimilation (B345/S4567), and a Super rule that spawns a random 3×3 block.',
        gameVersion: '0.4.9a',
        code: `(function(){
  // ----------------------------------------------------------------------
  // FORCE MOD IDENTIFICATION
  // ----------------------------------------------------------------------
  window.forcedModInfo = {
    id: 'gameOfLifeMod',
    title: 'Game Of Life Mod',
    description: 'Adds a suite of Game Of Life variants as new elements under a dedicated "Game Of Life Mod" category. Includes Conway’s, StructuredX (B278/S3456/6), Walled Cities (B45678/S2345), Seeds (B2/S), Gnarl (B1/S1), Diamoeba (B35678/S5678), Stains (B3678/S235678), Long Life (B345/S5), Maze (B3/S12345), Coagulations (B378/S235678), 3-4 (B34/S34), Living On The Edge (B37/S3458/4), Assimilation (B345/S4567), and a Super rule that spawns a random 3×3 block.',
    gameVersion: '0.4.9a'
  };

  // ----------------------------------------------------------------------
  // DEFINE MOD ELEMENT IDENTIFIERS (as strings)
  // ----------------------------------------------------------------------
  const CONWAYS         = "CONWAYS";
  const STRUCTUREDX     = "STRUCTUREDX";
  const WALLED_CITIES   = "WALLED_CITIES";
  const SEEDS           = "SEEDS";
  const GNARL           = "GNARL";
  const DIAMOEBA        = "DIAMOEBA";
  const STAINS          = "STAINS";
  const LONG_LIFE       = "LONG_LIFE";
  const MAZE            = "MAZE";
  const COAGULATIONS    = "COAGULATIONS";
  const THREE_FOUR      = "THREE_FOUR";
  const LIVING_ON_THE_EDGE = "LIVING_ON_THE_EDGE";
  const ASSIMILATION    = "ASSIMILATION";
  const SUPER           = "SUPER";

  // Array of all standard mod types (exclude SUPER)
  const modTypes = [CONWAYS, STRUCTUREDX, WALLED_CITIES, SEEDS, GNARL, DIAMOEBA, STAINS, LONG_LIFE, MAZE, COAGULATIONS, THREE_FOUR, LIVING_ON_THE_EDGE, ASSIMILATION];

  // ----------------------------------------------------------------------
  // RULE SPECIFICATIONS
  // ----------------------------------------------------------------------
  // Each rule: "birth" and "survival" arrays; optionally "maxAge" for age‐tracked rules.
  const ruleSet = {
    [CONWAYS]:         { birth: [3],         survival: [2,3] },
    [STRUCTUREDX]:     { birth: [2,7,8],     survival: [3,4,5,6], maxAge: 6 },
    [WALLED_CITIES]:   { birth: [4,5,6,7,8],  survival: [2,3,4,5] },
    [SEEDS]:           { birth: [2],         survival: [] },
    [GNARL]:           { birth: [1],         survival: [1] },
    [DIAMOEBA]:        { birth: [3,5,6,7,8],  survival: [5,6,7,8] },
    [STAINS]:          { birth: [3,6,7,8],    survival: [2,3,5,6,7,8] },
    [LONG_LIFE]:       { birth: [3,4,5],      survival: [5] },
    [MAZE]:            { birth: [3],         survival: [1,2,3,4,5] },
    [COAGULATIONS]:    { birth: [3,7,8],      survival: [2,3,5,6,7,8] },
    [THREE_FOUR]:      { birth: [3,4],        survival: [3,4] },
    [LIVING_ON_THE_EDGE]: { birth: [3,7],     survival: [3,4,5,8], maxAge: 4 },
    [ASSIMILATION]:    { birth: [3,4,5],      survival: [4,5,6,7] }
  };

  // ----------------------------------------------------------------------
  // GLOBAL AGE ARRAYS FOR AGE-TRACKED MOD CELLS
  // ----------------------------------------------------------------------
  // For StructuredX and Living On The Edge.
  if(typeof window.structuredXAge === "undefined"){
    window.structuredXAge = [];
    for(let y=0; y<GRID_SIZE; y++){
      structuredXAge[y] = [];
      for(let x=0; x<GRID_SIZE; x++){
        structuredXAge[y][x] = null;
      }
    }
  }
  if(typeof window.livingOnTheEdgeAge === "undefined"){
    window.livingOnTheEdgeAge = [];
    for(let y=0; y<GRID_SIZE; y++){
      livingOnTheEdgeAge[y] = [];
      for(let x=0; x<GRID_SIZE; x++){
        livingOnTheEdgeAge[y][x] = null;
      }
    }
  }

  // ----------------------------------------------------------------------
  // SAVE ORIGINAL CATEGORY BUTTON FUNCTIONALITY (for later cleanup)
  // ----------------------------------------------------------------------
  // (Assumes global filterTools exists.)
  let origFilterTools = filterTools;
  filterTools = function(){
    origFilterTools();
    // When activeCategory is not our mod category, remove selected styling from our mod tools.
    if(activeCategory !== "game-of-life-mod"){
      document.querySelectorAll(".tool").forEach(tool => {
        if(tool.getAttribute("data-cat") === "game-of-life-mod"){
          tool.classList.remove("selected");
        }
      });
    }
  };

  // ----------------------------------------------------------------------
  // ADD CUSTOM CSS FOR TOOLBAR & CATEGORY BUTTONS
  // ----------------------------------------------------------------------
  let style2 = document.createElement('style');
  style2.innerHTML = \`
    .tool.conways { background-color: #00aaff !important; }
    .tool.structuredx { background-color: #ffaa00 !important; }
    .tool.walled_cities { background-color: #aa00ff !important; }
    .tool.seeds { background-color: #00ff00 !important; }
    .tool.gnarl { background-color: #8888ff !important; }
    .tool.diamoeba { background-color: #ff88aa !important; }
    .tool.stains { background-color: #aaffaa !important; }
    .tool.long_life { background-color: #ffcc00 !important; }
    .tool.maze { background-color: #ccffcc !important; }
    .tool.coagulations { background-color: #ff99ff !important; }
    .tool.three_four { background-color: #99ffff !important; }
    .tool.living_on_the_edge { background-color: #ff9999 !important; }
    .tool.assimilation { background-color: #ffff99 !important; }
    .tool.super { background-color: #ffffff !important; color: #000; }
    /* Category button for Game Of Life Mod */
    #categoryMenu button.game-of-life-mod {
      background-color: #444;
      color: #fff;
      border: 1px solid #888;
      border-radius: 3px;
      margin-bottom: 5px;
      padding: 10px;
      text-align: center;
      cursor: pointer;
      outline: none;
      box-shadow: none;
    }
    #categoryMenu button.game-of-life-mod.selectedCat {
      border: 2px solid #ffd700;
    }
    #categoryMenu button:focus {
      outline: none;
      box-shadow: none;
    }
  \`;
  document.head.appendChild(style2);

  // ----------------------------------------------------------------------
  // HARD CODE THE "Game Of Life Mod" CATEGORY BUTTON INTO THE CATEGORY MENU
  // ----------------------------------------------------------------------
  let categoryMenu = document.getElementById('categoryMenu');
  if(categoryMenu){
    if(!categoryMenu.querySelector("button[data-category='game-of-life-mod']")){
      let btn = document.createElement("button");
      btn.setAttribute("data-category", "game-of-life-mod");
      btn.classList.add("game-of-life-mod");
      btn.textContent = "Game Of Life Mod";
      categoryMenu.appendChild(btn);
      btn.addEventListener('click', function(){
        document.querySelectorAll("#categoryMenu button").forEach(b => b.classList.remove("selectedCat"));
        btn.classList.add("selectedCat");
        activeCategory = "game-of-life-mod";
        filterTools();
      });
    }
  }

  // ----------------------------------------------------------------------
  // ADD TOOL BUTTONS FOR EACH MOD ELEMENT (including SUPER)
  // ----------------------------------------------------------------------
  function createToolButton(modId, label, cssClass) {
    let btn = document.createElement('div');
    btn.className = 'tool ' + cssClass;
    btn.setAttribute('data-tool', modId);
    btn.setAttribute('data-cat', 'game-of-life-mod');
    btn.title = modId;
    let span = document.createElement('span');
    span.textContent = label;
    btn.appendChild(span);
    toolbar.appendChild(btn);
    btn.addEventListener('click', function(){
      selectTool(btn);
    });
  }
  createToolButton(CONWAYS, "Con", "conways");
  createToolButton(STRUCTUREDX, "Str", "structuredx");
  createToolButton(WALLED_CITIES, "Wal", "walled_cities");
  createToolButton(SEEDS, "Seed", "seeds");
  createToolButton(GNARL, "Gnar", "gnarl");
  createToolButton(DIAMOEBA, "Dia", "diamoeba");
  createToolButton(STAINS, "Sta", "stains");
  createToolButton(LONG_LIFE, "Lon", "long_life");
  createToolButton(MAZE, "Maz", "maze");
  createToolButton(COAGULATIONS, "Coag", "coagulations");
  createToolButton(THREE_FOUR, "3-4", "three_four");
  createToolButton(LIVING_ON_THE_EDGE, "Edge", "living_on_the_edge");
  createToolButton(ASSIMILATION, "Assim", "assimilation");
  createToolButton(SUPER, "Super", "super");

  // ----------------------------------------------------------------------
  // PATCH selectTool TO HANDLE OUR MOD TOOLS
  // ----------------------------------------------------------------------
  let origSelectTool = selectTool;
  selectTool = function(el){
    let tool = el.getAttribute('data-tool');
    if(modTypes.concat([SUPER]).includes(tool)){
      currentTool = tool;
      Array.from(toolElements).forEach(t => t.classList.remove('selected'));
      el.classList.add('selected');
    } else {
      origSelectTool(el);
    }
  };

  // ----------------------------------------------------------------------
  // PATCH placeElementAt TO PLACE OUR MOD CELLS
  // ----------------------------------------------------------------------
  let origPlaceElementAt = placeElementAt;
  placeElementAt = function(x, y, tool){
    if(modTypes.concat([SUPER]).includes(tool)){
      // When placing a SUPER, simply place it.
      if(tool === SUPER){
        eraseCell(x,y);
        grid[y][x] = SUPER;
        temp[y][x] = 20;
        return;
      }
      // For standard mod cells, place and initialize age if needed.
      eraseCell(x,y);
      grid[y][x] = tool;
      temp[y][x] = 20;
      if(tool === STRUCTUREDX){
        structuredXAge[y][x] = 0;
      }
      if(tool === LIVING_ON_THE_EDGE){
        livingOnTheEdgeAge[y][x] = 0;
      }
      return;
    } else {
      origPlaceElementAt(x, y, tool);
    }
  };

  // ----------------------------------------------------------------------
  // PATCH getElementName TO REPORT OUR MOD ELEMENT NAMES
  // ----------------------------------------------------------------------
  let origGetElementName = getElementName;
  getElementName = function(e){
    switch(e){
      case CONWAYS: return "Conway's Game Of Life";
      case STRUCTUREDX: return "StructuredX (B278/S3456/6)";
      case WALLED_CITIES: return "Walled Cities (B45678/S2345)";
      case SEEDS: return "Seeds (B2/S)";
      case GNARL: return "Gnarl (B1/S1)";
      case DIAMOEBA: return "Diamoeba (B35678/S5678)";
      case STAINS: return "Stains (B3678/S235678)";
      case LONG_LIFE: return "Long Life (B345/S5)";
      case MAZE: return "Maze (B3/S12345)";
      case COAGULATIONS: return "Coagulations (B378/S235678)";
      case THREE_FOUR: return "3-4 (B34/S34)";
      case LIVING_ON_THE_EDGE: return "Living On The Edge (B37/S3458/4)";
      case ASSIMILATION: return "Assimilation (B345/S4567)";
      case SUPER: return "Super [Modded]";
      default: return origGetElementName(e);
    }
  };

  // ----------------------------------------------------------------------
  // PATCH renderCell TO RENDER OUR MOD CELLS WITH COLORS
  // ----------------------------------------------------------------------
  let origRenderCell = renderCell;
  renderCell = function(x,y){
    const cell = cells[y][x];
    cell.className = 'cell';
    cell.style.opacity = "";
    cell.style.backgroundColor = "";
    let e = grid[y][x];
    switch(e){
      case CONWAYS: cell.style.backgroundColor = "#00aaff"; break;
      case STRUCTUREDX: cell.style.backgroundColor = "#ffaa00"; break;
      case WALLED_CITIES: cell.style.backgroundColor = "#aa00ff"; break;
      case SEEDS: cell.style.backgroundColor = "#00ff00"; break;
      case GNARL: cell.style.backgroundColor = "#8888ff"; break;
      case DIAMOEBA: cell.style.backgroundColor = "#ff88aa"; break;
      case STAINS: cell.style.backgroundColor = "#aaffaa"; break;
      case LONG_LIFE: cell.style.backgroundColor = "#ffcc00"; break;
      case MAZE: cell.style.backgroundColor = "#ccffcc"; break;
      case COAGULATIONS: cell.style.backgroundColor = "#ff99ff"; break;
      case THREE_FOUR: cell.style.backgroundColor = "#99ffff"; break;
      case LIVING_ON_THE_EDGE: cell.style.backgroundColor = "#ff9999"; break;
      case ASSIMILATION: cell.style.backgroundColor = "#ffff99"; break;
      case SUPER: cell.style.backgroundColor = "#ffffff"; break;
      default: origRenderCell(x,y);
    }
  };

  // ----------------------------------------------------------------------
  // GAME OF LIFE SIMULATION FUNCTION
  // ----------------------------------------------------------------------
  function gameOfLifeStep(){
    // We'll only update cells that are either EMPTY or one of our mod types.
    let newState = [];
    // For age-tracked cells.
    let newStructuredXAge = [];
    let newLivingOnTheEdgeAge = [];
    for(let y=0; y<GRID_SIZE; y++){
      newState[y] = [];
      newStructuredXAge[y] = [];
      newLivingOnTheEdgeAge[y] = [];
      for(let x=0; x<GRID_SIZE; x++){
        newState[y][x] = grid[y][x];
        newStructuredXAge[y][x] = structuredXAge[y][x];
        newLivingOnTheEdgeAge[y][x] = livingOnTheEdgeAge[y][x];
      }
    }
    const offsets = [
      [-1,-1],[0,-1],[1,-1],
      [-1, 0],       [1, 0],
      [-1, 1],[0, 1],[1, 1]
    ];
    // Process each cell.
    for(let y=0; y<GRID_SIZE; y++){
      for(let x=0; x<GRID_SIZE; x++){
        let cell = grid[y][x];
        // Only process if cell is EMPTY or one of our mod types.
        if(cell === EMPTY || modTypes.concat([STRUCTUREDX, WALLED_CITIES, SEEDS, GNARL, DIAMOEBA, STAINS, LONG_LIFE, MAZE, COAGULATIONS, THREE_FOUR, LIVING_ON_THE_EDGE, ASSIMILATION, CONWAYS]).includes(cell)){
          // Special handling for SUPER: immediately generate a 3x3 block.
          if(cell === SUPER){
            for(let dy = -1; dy <= 1; dy++){
              for(let dx = -1; dx <= 1; dx++){
                let nx = x + dx, ny = y + dy;
                if(nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE){
                  // Pick a random mod type (excluding SUPER).
                  let rnd = modTypes[Math.floor(Math.random() * modTypes.length)];
                  newState[ny][nx] = rnd;
                  temp[ny][nx] = 20;
                  if(rnd === STRUCTUREDX) newStructuredXAge[ny][nx] = 0;
                  if(rnd === LIVING_ON_THE_EDGE) newLivingOnTheEdgeAge[ny][nx] = 0;
                }
              }
            }
            continue;
          }
          // For live mod cells, count neighbors of the same type.
          let counts = {};
          // We'll count only neighbors that are the same mod type.
          if(cell !== EMPTY){
            counts[cell] = 0;
            offsets.forEach(off=>{
              let nx = x + off[0], ny = y + off[1];
              if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<GRID_SIZE){
                if(grid[ny][nx] === cell) counts[cell]++;
              }
            });
          }
          // Process survival and death if cell is live.
          if(cell !== EMPTY){
            let rule = ruleSet[cell];
            if(rule){
              // For age-tracked rules.
              if(rule.maxAge){
                let age = (cell === STRUCTUREDX) ? (structuredXAge[y][x]||0) : (livingOnTheEdgeAge[y][x]||0);
                if(!(rule.survival.includes(counts[cell]) && age < rule.maxAge)){
                  newState[y][x] = EMPTY;
                  if(cell === STRUCTUREDX) newStructuredXAge[y][x] = null;
                  if(cell === LIVING_ON_THE_EDGE) newLivingOnTheEdgeAge[y][x] = null;
                } else {
                  newState[y][x] = cell;
                  if(cell === STRUCTUREDX) newStructuredXAge[y][x] = age + 1;
                  if(cell === LIVING_ON_THE_EDGE) newLivingOnTheEdgeAge[y][x] = age + 1;
                }
              } else {
                if(!rule.survival.includes(counts[cell])){
                  newState[y][x] = EMPTY;
                } else {
                  newState[y][x] = cell;
                }
              }
            }
          } else {
            // For empty cells, try births in a fixed order.
            for(let i=0; i<modTypes.length; i++){
              let type = modTypes[i];
              let rule = ruleSet[type];
              let ncount = 0;
              offsets.forEach(off=>{
                let nx = x + off[0], ny = y + off[1];
                if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<GRID_SIZE){
                  if(grid[ny][nx] === type) ncount++;
                }
              });
              if(rule && rule.birth.includes(ncount)){
                newState[y][x] = type;
                temp[y][x] = 20;
                if(type === STRUCTUREDX) newStructuredXAge[y][x] = 0;
                if(type === LIVING_ON_THE_EDGE) newLivingOnTheEdgeAge[y][x] = 0;
                break;
              }
            }
          }
        }
      }
    }
    // Write new state back to grid and update ages.
    for(let y=0; y<GRID_SIZE; y++){
      for(let x=0; x<GRID_SIZE; x++){
        if(modTypes.concat([STRUCTUREDX, WALLED_CITIES, SEEDS, GNARL, DIAMOEBA, STAINS, LONG_LIFE, MAZE, COAGULATIONS, THREE_FOUR, LIVING_ON_THE_EDGE, ASSIMILATION, CONWAYS]).includes(newState[y][x])){
          grid[y][x] = newState[y][x];
          temp[y][x] = 20;
          if(newState[y][x] === STRUCTUREDX) structuredXAge[y][x] = newStructuredXAge[y][x];
          if(newState[y][x] === LIVING_ON_THE_EDGE) livingOnTheEdgeAge[y][x] = newLivingOnTheEdgeAge[y][x];
        } else if(grid[y][x] !== EMPTY && newState[y][x] === EMPTY){
          grid[y][x] = EMPTY;
          temp[y][x] = null;
          if(grid[y][x] === STRUCTUREDX) structuredXAge[y][x] = null;
          if(grid[y][x] === LIVING_ON_THE_EDGE) livingOnTheEdgeAge[y][x] = null;
        }
      }
    }
    // Special interaction: if an empty cell has neighbors of at least two different mod types, with a small chance, spawn a new mod cell.
    for(let y=0; y<GRID_SIZE; y++){
      for(let x=0; x<GRID_SIZE; x++){
        if(grid[y][x] === EMPTY){
          let neighborTypes = new Set();
          offsets.forEach(off=>{
            let nx = x + off[0], ny = y + off[1];
            if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<GRID_SIZE){
              let n = grid[ny][nx];
              if(modTypes.concat([STRUCTUREDX, WALLED_CITIES, SEEDS, GNARL, DIAMOEBA, STAINS, LONG_LIFE, MAZE, COAGULATIONS, THREE_FOUR, LIVING_ON_THE_EDGE, ASSIMILATION, CONWAYS]).includes(n)){
                neighborTypes.add(n);
              }
            }
          });
          if(neighborTypes.size >= 2 && Math.random() < 0.005){
            // Choose a new mod type that is not already present if possible.
            let available = modTypes.filter(t => !neighborTypes.has(t));
            let newType = available.length > 0 ? available[Math.floor(Math.random() * available.length)] : modTypes[Math.floor(Math.random() * modTypes.length)];
            grid[y][x] = newType;
            temp[y][x] = 20;
            if(newType === STRUCTUREDX) structuredXAge[y][x] = 0;
            if(newType === LIVING_ON_THE_EDGE) livingOnTheEdgeAge[y][x] = 0;
          }
        }
      }
    }
  }

  // ----------------------------------------------------------------------
  // PATCH performSimulationStep TO INCLUDE GAME OF LIFE UPDATES
  // ----------------------------------------------------------------------
  let origPerformSimStep = performSimulationStep;
  performSimulationStep = function(){
    origPerformSimStep();
    gameOfLifeStep();
  };

})();
`
      },
      {
        id: 'guiApiMod',
        title: 'GUI API Mod',
        description: 'Provides a comprehensive set of customizable GUI options (draggable/resizable windows, forms, etc.) that other mods can use via window.ModGUIAPI.',
        gameVersion: '0.4.9a',
        code: `(function(){
  // FORCE MOD IDENTIFICATION
  window.forcedModInfo = {
    id: 'guiApiMod',
    title: 'GUI API Mod',
    description: 'Provides a comprehensive set of customizable GUI options (draggable/resizable windows, forms, etc.) that other mods can use via window.ModGUIAPI.',
    gameVersion: '0.4.9a'
  };

  // Expose a global API object for creating GUI elements.
  window.ModGUIAPI = {
    /**
     * Creates a draggable, resizable window.
     * Options (all optional):
     *   - title: Title text (default "Window")
     *   - width: Width (default "300px")
     *   - height: Height (default "200px")
     *   - top: Top position (default "100px")
     *   - left: Left position (default "100px")
     *   - backgroundColor: Window background color (default "rgba(0,0,0,0.9)")
     *   - color: Text color (default "#fff")
     *   - headerColor: Header background (default "#222")
     *   - content: HTML string or an HTMLElement to be placed inside the window
     *   - onClose: Callback when window is closed.
     */
    createWindow: function(options) {
      options = options || {};
      let win = document.createElement("div");
      win.style.position = "fixed";
      win.style.top = options.top || "100px";
      win.style.left = options.left || "100px";
      win.style.width = options.width || "300px";
      win.style.height = options.height || "200px";
      win.style.backgroundColor = options.backgroundColor || "rgba(0,0,0,0.9)";
      win.style.color = options.color || "#fff";
      win.style.padding = "10px";
      win.style.border = "1px solid #888";
      win.style.zIndex = "3000";
      win.style.boxSizing = "border-box";
      win.style.overflow = "auto";
      win.style.resize = "both";

      // Header (for dragging)
      let header = document.createElement("div");
      header.textContent = options.title || "Window";
      header.style.cursor = "move";
      header.style.backgroundColor = options.headerColor || "#222";
      header.style.padding = "5px";
      header.style.fontWeight = "bold";
      win.appendChild(header);

      // Close button
      let closeBtn = document.createElement("button");
      closeBtn.textContent = "Close";
      closeBtn.style.position = "absolute";
      closeBtn.style.top = "5px";
      closeBtn.style.right = "5px";
      closeBtn.style.backgroundColor = "#444";
      closeBtn.style.color = "#fff";
      closeBtn.style.border = "none";
      closeBtn.style.cursor = "pointer";
      closeBtn.addEventListener("click", function(){
        if(options.onClose) options.onClose();
        win.parentNode.removeChild(win);
      });
      win.appendChild(closeBtn);

      // Content container
      let contentContainer = document.createElement("div");
      contentContainer.style.marginTop = "40px"; // leave room for header/close
      if(options.content){
        if(typeof options.content === "string"){
          contentContainer.innerHTML = options.content;
        } else if(options.content instanceof HTMLElement){
          contentContainer.appendChild(options.content);
        }
      }
      win.appendChild(contentContainer);

      // Draggable functionality for the header
      header.onmousedown = function(e){
        e.preventDefault();
        let pos3 = e.clientX, pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
        function elementDrag(e){
          e.preventDefault();
          let pos1 = pos3 - e.clientX;
          let pos2 = pos4 - e.clientY;
          pos3 = e.clientX;
          pos4 = e.clientY;
          win.style.top = (win.offsetTop - pos2) + "px";
          win.style.left = (win.offsetLeft - pos1) + "px";
        }
        function closeDragElement(){
          document.onmouseup = null;
          document.onmousemove = null;
        }
      };

      document.body.appendChild(win);
      return win;
    },

    /**
     * Creates a simple form.
     * options.fields should be an array of objects, each with:
     *   - label: string,
     *   - type: "text", "number", or "checkbox",
     *   - default: default value,
     *   - onChange: function(value) {}
     */
    createForm: function(options) {
      options = options || {};
      let form = document.createElement("form");
      form.style.fontFamily = "Arial, sans-serif";
      if(options.fields && Array.isArray(options.fields)){
        options.fields.forEach(function(field){
          let fieldContainer = document.createElement("div");
          fieldContainer.style.marginBottom = "8px";
          let label = document.createElement("label");
          label.textContent = field.label + ": ";
          fieldContainer.appendChild(label);
          let input;
          if(field.type === "checkbox"){
            input = document.createElement("input");
            input.type = "checkbox";
            input.checked = field.default;
          } else {
            input = document.createElement("input");
            input.type = field.type || "text";
            input.value = field.default || "";
            input.style.width = "60px";
          }
          input.addEventListener("change", function(){
            if(field.onChange) {
              let val = (input.type === "checkbox") ? input.checked : input.value;
              field.onChange(val);
            }
          });
          fieldContainer.appendChild(input);
          form.appendChild(fieldContainer);
        });
      }
      return form;
    },

    /**
     * Creates a button.
     * options: { text: string, onClick: function() {}, style: {} }
     */
    createButton: function(options) {
      options = options || {};
      let btn = document.createElement("button");
      btn.textContent = options.text || "Button";
      if(options.style && typeof options.style === "object"){
        Object.assign(btn.style, options.style);
      }
      btn.addEventListener("click", function(e){
        if(options.onClick) options.onClick(e);
      });
      return btn;
    },

    /**
     * Creates a simple label element.
     * options: { text: string, style: {} }
     */
    createLabel: function(options) {
      options = options || {};
      let label = document.createElement("label");
      label.textContent = options.text || "";
      if(options.style && typeof options.style === "object"){
        Object.assign(label.style, options.style);
      }
      return label;
    }
  };

  console.log("[GUI API Mod] Loaded. Use window.ModGUIAPI to create custom GUI elements.");
})();
`
      }
    ];

    // Function to create mod cards
    function createModCards() {
      const container = document.getElementById('modContainer');
      container.innerHTML = '';
      mods.forEach(mod => {
        const card = document.createElement('div');
        card.className = 'mod-card';
        card.innerHTML = `
          <h2>${mod.title}</h2>
          <p>${mod.description}</p>
          <small>Game Version: ${mod.gameVersion}</small>
          <pre class="mod-code" id="code-${mod.id}">${mod.code.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
          <button class="copy-button" data-modid="${mod.id}">Copy Code</button>
        `;
        container.appendChild(card);
      });
    }

    // Copy button functionality
    document.addEventListener('click', function(e) {
      if (e.target && e.target.classList.contains('copy-button')) {
        const modId = e.target.getAttribute('data-modid');
        const codeElement = document.getElementById('code-' + modId);
        if (codeElement) {
          const codeText = codeElement.textContent;
          navigator.clipboard.writeText(codeText).then(() => {
            e.target.textContent = 'Copied!';
            setTimeout(() => {
              e.target.textContent = 'Copy Code';
            }, 2000);
          });
        }
      }
    });

    // Search functionality
    document.getElementById('searchBar').addEventListener('input', function(e) {
      const query = e.target.value.toLowerCase();
      const cards = document.querySelectorAll('.mod-card');
      cards.forEach(card => {
        const title = card.querySelector('h2').textContent.toLowerCase();
        const desc = card.querySelector('p').textContent.toLowerCase();
        if (title.includes(query) || desc.includes(query)) {
          card.style.display = 'block';
        } else {
          card.style.display = 'none';
        }
      });
    });

    // Initialize
    createModCards();
  </script>
</body>
</html>
